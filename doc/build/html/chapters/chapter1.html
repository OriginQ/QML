

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>QARM说明文档 &mdash; QML用户手册 0.1.1 文档</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="QSVM说明文档" href="chapter2.html" />
    <link rel="prev" title="QML用户手册" href="../index.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> QML用户手册
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">QARM说明文档</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#association-rules-mining">1.关联规则挖掘（Association Rules Mining）简介</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">1.1关联规则</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">1.2关联规则的相关概念</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">1.3 关联分析目标</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id4">2. QARM解决的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">3. 实现步骤</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">3.1 使用经典算法得到候选1项集</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">3.2 根据具体数据进行二进制线路的编码</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">3.3 构建量子黑盒线路，实现数据的编码</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">3.4 数据查询线路</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">3.5 相位转移线路</a></li>
<li class="toctree-l3"><a class="reference internal" href="#oracle">3.6 Oracle线路</a></li>
<li class="toctree-l3"><a class="reference internal" href="#coin">3.7 coin线路</a></li>
<li class="toctree-l3"><a class="reference internal" href="#g-k">3.8 G(k)线路</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">3.9 循环迭代</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">3.10 对查询结果的索引进行处理</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">3.11 找出频繁1项集</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kk-1">3.12 根据频繁k项集得到频繁k+1项集</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id14">3.13 统计所有频繁项集</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">3.14 置信度计算</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id16">4.所有代码和测试结果</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id17">5.总结</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="chapter2.html">QSVM说明文档</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QML用户手册</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>QARM说明文档</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/chapters/chapter1.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="qarm">
<h1>QARM说明文档<a class="headerlink" href="#qarm" title="永久链接至标题">¶</a></h1>
<p><strong>version：3.1</strong></p>
<p><strong>Author：李蕾</strong></p>
<p><strong>Update Date：20200509</strong></p>
<div class="section" id="association-rules-mining">
<h2>1.关联规则挖掘（Association Rules Mining）简介<a class="headerlink" href="#association-rules-mining" title="永久链接至标题">¶</a></h2>
<div class="section" id="id1">
<h3>1.1关联规则<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>在网上购物时，系统会主动推荐一些商品，赠送一些优惠券，并且这些推荐的商品和赠送的优惠券往往都能直抵我们的需求，诱导我们消费。这背后主要使用使用了关联分析技术，通过分析哪些商品经常一起购买，可以帮助商家了解用户的购买行为。从大规模数据中挖掘对象之间的隐含关系被称为关联分析（associate analysis）或者关联规则学习（associate rule learning），其可以揭示数据中隐藏的关联模式，帮助人们进行市场运作，决策支持等。</p>
</div>
<div class="section" id="id2">
<h3>1.2关联规则的相关概念<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p><span class="math notranslate nohighlight">\(I=\left\{i_{1}, i_{2}, \ldots, i_{n}\right\}\)</span> 被称为项集（items），其中:math:<cite>i_j∈{0,1}</cite> 被称为项。</p>
<p><span class="math notranslate nohighlight">\(D=\left\{t_{1}, t_{2}, \ldots, t_{m}\right\}\)</span> 被称为数据库（database）其中:math:<cite>t_{k}</cite> 被称为事务（transaction）。</p>
<p>事务是项的集合，即事务是:math:<cite>I</cite> 的一个子集，<span class="math notranslate nohighlight">\(t_{k} \subseteq I\)</span> ，每个事务用一个唯一的transaction ID进行标识。规则（rule）定义如下：</p>
<p><span class="math notranslate nohighlight">\(X \Rightarrow Y\)</span> ，其中 <span class="math notranslate nohighlight">\(X, Y \subseteq I\)</span></p>
<p>为了从所有可能的规则集中选出有趣的规则（interesting rules），需要用到各种重要度（significance）、兴趣度（interest）约束，其中最有名的是支持度（support）和置信度（confidence）。</p>
<p>1.支持度support：数据集中包含该项集的数据所占数据集的比例，度量一个集合在原始数据中出现的频率</p>
<p>2.置信度confidence：是针对一条关联规则来定义的，a-&gt;b的置信度=支持度{a|b}/支持度{a}，a|b表示ab的并集</p>
</div>
<div class="section" id="id3">
<h3>1.3 关联分析目标<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<ol class="arabic simple">
<li><p>发现频繁项集（频繁项集是满足最小支持度要求的项集，它给出经常在一起出现的元素项）</p></li>
<li><p>发现关联规则（关联规则意味着元素项之间“如果…那么…”的关系）</p></li>
</ol>
<p><strong>Apriori原理，</strong></p>
<ol class="arabic simple">
<li><p>如果某个项集是频繁的，那么它的所有子集也是频繁的</p></li>
<li><p>如果某个项集是非频繁的，那么它的所有超集也是非频繁的</p></li>
<li><p>基于此，Apriori算法从单元素项集开始，通过组合满足最小支持度的项集来形成更大的集合</p></li>
</ol>
</div>
</div>
<div class="section" id="id4">
<h2>2. QARM解决的问题<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>基于著名的经典关联规则挖掘算法Apriori算法，提出一个实现该核心任务的量子关联规则挖掘算法。具体来说，在给定访问交易数据库的量子黑盒的条件下，该算法首先利用量子并行幅度估计算法以量子并行方式估计所有候选k项集的支持度，并将其存储于一个量子叠加态中。接下来，使用量子幅度放大算法，从该叠加量子态中搜索出那些不小于预定阈值的候选k项集，即频繁k项集。</p>
</div>
<div class="section" id="id5">
<h2>3. 实现步骤<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>对于交易数据库，含有N个交易的交易集，记为:math:<cite>mathscr{T}=left{T_{0}, T_{1}, cdots, T_{N-1}right}</cite> ，每项交易是:math:<cite>M</cite> 个项集:math:<cite>mathscr{I}=left{I_{0}, I_{1}, cdots, I_{M-1}right}</cite> 的子集来构成，每个交易包含于:math:<cite>M</cite> 项集，即:math:<cite>T_{i} subseteq mathscr{I}</cite> 。因此交易数据库可以表示为一个:math:<cite>N times M</cite> 的编码矩阵，记为:math:<cite>D</cite> ，其中元素:math:<cite>D_{i j}not=0</cite> 表示交易:math:<cite>T_{i}</cite> 中包含:math:<cite>I_{j}</cite> 项，否则元素:math:<cite>D_{i j}=0</cite> 。</p>
<p>示例如下：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 39%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>交易</p></th>
<th class="head"><p>项（商品）</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(T_{0}\)</span></p></td>
<td><p>面包、奶酪、牛奶</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(T_{1}\)</span></p></td>
<td><p>面包、黄油</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(T_{2}\)</span></p></td>
<td><p>奶酪、牛奶</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(T_{3}\)</span></p></td>
<td><p>面包、奶酪</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(T_{4}\)</span></p></td>
<td><p>奶酪、黄油、牛奶</p></td>
</tr>
</tbody>
</table>
<p>可以用如下矩阵表示</p>
<p><span class="math notranslate nohighlight">\(\left(\begin{array}{llll}1 &amp; 2 &amp; 3 &amp; 0 \\ 0 &amp; 0 &amp; 3 &amp; 4 \\ 1 &amp; 2 &amp; 0 &amp; 0 \\ 1 &amp; 0 &amp; 3 &amp; 0 \\ 1 &amp; 2 &amp; 0 &amp; 4\end{array}\right)\)</span></p>
<p>其中{1: ‘奶酪’, 2: ‘牛奶’, 3: ‘面包’, 4: ‘黄油’}，0表示没有此项</p>
<div class="section" id="id6">
<h3>3.1 使用经典算法得到候选1项集<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 获取候选1项集，data_set为转化后的数字交易信息，不包含0数字。返回一个list，每个元素都是tuple元组</span>
   <span class="k">def</span> <span class="nf">create_c1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_set</span><span class="p">):</span>
       <span class="n">c1</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 元素个数为1的项集（非频繁项集，因为还没有同最小支持度比较）</span>
       <span class="k">for</span> <span class="n">transaction</span> <span class="ow">in</span> <span class="n">data_set</span><span class="p">:</span>
           <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">transaction</span><span class="p">:</span>
               <span class="k">if</span> <span class="ow">not</span> <span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="ow">in</span> <span class="n">c1</span> <span class="ow">and</span> <span class="n">item</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                   <span class="n">c1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">item</span><span class="p">])</span>
       <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">c1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>3.2 根据具体数据进行二进制线路的编码<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>该编码是为了方便其他函数的使用，其代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 根据当前number绘制子线路</span>
<span class="k">def</span> <span class="nf">get_number_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">qubit_number</span><span class="p">):</span>
    <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="c1"># 把当前item的数字变成二进制数字符串，并去除前面的0b字符</span>
    <span class="n">bin_str</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">number</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;0b&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="c1"># 对于不足量子比特数的前面用0进行补齐，并逆排序</span>
    <span class="n">bin_str</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">qubit_number</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_str</span><span class="p">))</span> <span class="o">*</span> <span class="s1">&#39;0&#39;</span> <span class="o">+</span> <span class="n">bin_str</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bin_str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">bit</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="n">j</span><span class="p">]))</span>
            <span class="c1"># print(&#39;画子线路&#39;)</span>
            <span class="c1"># pq.draw_qprog(cir)</span>
            <span class="k">return</span> <span class="n">cir</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>3.3 构建量子黑盒线路，实现数据的编码<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>对交易数据库，进行二维编码，每一行是一条交易信息，每一列表示所含的项，使用行列两个索引来表示交易数据。对每一个项进行独立数字表示，形如本节一开始介绍，称此线路为U 线路。</p>
<p>其线路编码结构如下：</p>
<img alt="../_images/数据编码.png" class="align-center" src="../_images/数据编码.png" />
<p>其代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Oracle中的 U 线路编码</span>
<span class="k">def</span> <span class="nf">encode_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">index_qubit_number</span><span class="p">,</span> <span class="n">items_length</span><span class="p">,</span>  <span class="n">transaction_number</span><span class="p">):</span>
    <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>

    <span class="c1"># 控制子线路的量子比特，对应索引空间的比特数</span>
    <span class="n">control_qubit</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index_qubit_number</span><span class="p">):</span>
        <span class="n">control_qubit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>

        <span class="c1"># 编码信息的位置</span>
        <span class="n">information_position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">index_qubit_number</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">transaction_number</span><span class="p">):</span>
            <span class="c1"># 对交易行索引量子线路进行 X 门编码</span>
            <span class="n">t_x_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">items_qubit_number</span><span class="p">,</span>
                                              <span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction_qubit_number</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span>  <span class="bp">self</span><span class="o">.</span><span class="n">transaction_qubit_number</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">items_length</span><span class="p">):</span>
                <span class="c1"># 对项列索引量子线路进行 X 门编码</span>
                <span class="n">item_x_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span> <span class="n">items_qubit_number</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">m</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">items_qubit_number</span><span class="p">)</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">item_x_cir</span><span class="p">)</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">t_x_cir</span><span class="p">)</span>
                <span class="c1"># 对此行此列数字进行编码</span>
                <span class="n">sub_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">information_position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span> <span class="n">transaction_matrix</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">m</span><span class="p">],</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span><span class="p">)</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">sub_cir</span><span class="o">.</span><span class="n">control</span><span class="p">(</span><span class="n">control_qubit</span><span class="p">))</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">t_x_cir</span><span class="p">)</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">item_x_cir</span><span class="p">)</span>

                <span class="c1"># print(&#39;U线路：&#39;)</span>
                <span class="c1"># pq.draw_qprog(cir)</span>
                <span class="k">return</span> <span class="n">cir</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h3>3.4 数据查询线路<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>根据查询的数据进行线路编码，得到将要查询数据的索引，称此线路为S线路，其线路结构如下：</p>
<img alt="../_images/查询线路.png" class="align-center" src="../_images/查询线路.png" />
<p>其代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 定义Oracle中的查找线路 S</span>
<span class="k">def</span> <span class="nf">query_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">target_number</span><span class="p">):</span>
    <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="n">sub_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span> <span class="o">-</span>  <span class="n">target_number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span><span class="p">)</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">sub_cir</span><span class="p">)</span>
    <span class="n">control_qubit</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span><span class="p">):</span>
        <span class="n">control_qubit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span><span class="p">])</span><span class="o">.</span><span class="n">control</span><span class="p">(</span><span class="n">control_qubit</span><span class="p">))</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">sub_cir</span><span class="p">)</span>
    <span class="c1"># print(&#39;S线路：&#39;)</span>
    <span class="c1"># pq.draw_qprog(cir)</span>
    <span class="k">return</span> <span class="n">cir</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>3.5 相位转移线路<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>根据查询的结果，把相位进行转移，称此线路为Transfer，其结构如下：</p>
<img alt="../_images/相位转移.png" class="align-center" src="../_images/相位转移.png" />
<p>其代码实现如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 定义Oracle中的相位转移线路</span>
<span class="k">def</span> <span class="nf">transfer_to_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
    <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">U1</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">control</span><span class="p">([</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="p">]]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;相位转移线路：&#39;</span><span class="p">)</span>
    <span class="n">pq</span><span class="o">.</span><span class="n">draw_qprog</span><span class="p">(</span><span class="n">cir</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cir</span>
</pre></div>
</div>
</div>
<div class="section" id="oracle">
<h3>3.6 Oracle线路<a class="headerlink" href="#oracle" title="永久链接至标题">¶</a></h3>
<p>oracle线路实现相位取反操作，整体结构由U+S+Transfer+S.dagger+U.dagger()线路构成</p>
<p>其结构如下：</p>
<img alt="../_images/oracle线路.png" class="align-center" src="../_images/oracle线路.png" />
<p>其代码实现如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 定义oracle线路</span>
<span class="k">def</span> <span class="nf">oracle_cir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">locating_number</span><span class="p">):</span>
    <span class="c1"># U线路</span>
    <span class="n">u_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">items_length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction_number</span><span class="p">)</span>
    <span class="c1"># S线路</span>
    <span class="n">s_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">,</span> <span class="n">locating_number</span><span class="p">)</span>
    <span class="c1"># 相位转移线路</span>
    <span class="n">transfer_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transfer_to_phase</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span> <span class="n">digit_qubit_number</span><span class="p">)</span>

    <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">u_cir</span><span class="p">)</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s_cir</span><span class="p">)</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">transfer_cir</span><span class="p">)</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s_cir</span><span class="o">.</span><span class="n">dagger</span><span class="p">())</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">u_cir</span><span class="o">.</span><span class="n">dagger</span><span class="p">())</span>
    <span class="c1"># print(&#39;oracle线路：&#39;)</span>
    <span class="c1"># pq.draw_qprog(cir)</span>
    <span class="k">return</span> <span class="n">cir</span>
</pre></div>
</div>
</div>
<div class="section" id="coin">
<h3>3.7 coin线路<a class="headerlink" href="#coin" title="永久链接至标题">¶</a></h3>
<p>coin线路实现搜索结果的索引转移和提高结果的概率，其结构如下：</p>
<img alt="../_images/coin线路.png" class="align-center" src="../_images/coin线路.png" />
<p>实现代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 定义coin线路</span>
<span class="k">def</span> <span class="nf">coin_cir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
    <span class="n">u1_position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span>
    <span class="n">swap_interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span>
    <span class="n">coin_position</span> <span class="o">=</span> <span class="n">position</span>
    <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="n">control_qubit</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">):</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">coin_position</span> <span class="o">+</span> <span class="n">i</span><span class="p">]))</span>
        <span class="c1"># 变成0控</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">coin_position</span> <span class="o">+</span> <span class="n">i</span><span class="p">]))</span>
        <span class="c1"># 控制比特</span>
        <span class="n">control_qubit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">coin_position</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
    <span class="n">control_cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="c1"># 控制线路</span>
    <span class="n">control_cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">U1</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">u1_position</span><span class="p">],</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">control_cir</span><span class="o">.</span><span class="n">control</span><span class="p">(</span><span class="n">control_qubit</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">):</span>
        <span class="c1"># 控制线路还原</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">coin_position</span> <span class="o">+</span> <span class="n">i</span><span class="p">]))</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">coin_position</span> <span class="o">+</span> <span class="n">i</span><span class="p">]))</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">SWAP</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">coin_position</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span>
                        <span class="n">qlist</span><span class="p">[</span><span class="n">coin_position</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="n">swap_interval</span><span class="p">]))</span>
    <span class="c1"># print(&#39;coin 线路：&#39;)</span>
    <span class="c1"># pq.draw_qprog(cir)</span>
    <span class="k">return</span> <span class="n">cir</span>
</pre></div>
</div>
</div>
<div class="section" id="g-k">
<h3>3.8 G(k)线路<a class="headerlink" href="#g-k" title="永久链接至标题">¶</a></h3>
<p>G(k)线路结构如下：</p>
<img alt="../_images/Gk线路.png" class="align-center" src="../_images/Gk线路.png" />
<p>实现代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 定义G（k）线路</span>
<span class="k">def</span> <span class="nf">gk_cir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">locating_number</span><span class="p">):</span>
    <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="n">oracle_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oracle_cir</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">,</span> <span class="n">locating_number</span><span class="p">)</span>
    <span class="n">coin_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coin_cir</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">oracle_cir</span><span class="p">)</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">coin_cir</span><span class="p">)</span>
    <span class="c1"># print(&#39;G(k)线路：&#39;)</span>
    <span class="c1"># pq.draw_qprog(cir)</span>
    <span class="k">return</span> <span class="n">cir</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h3>3.9 循环迭代<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>通过一定次数的循环迭代，可在coin线路的索引上得到索引数据的概率分布，其中概率最大的，即是所查询的数据的结果索引，其线路结构如下：</p>
<img alt="../_images/迭代线路.png" class="align-center" src="../_images/迭代线路.png" />
<p>其代码实现如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 定义循环迭代线路</span>
<span class="k">def</span> <span class="nf">iter_cir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">locating_number</span><span class="p">,</span> <span class="n">iter_number</span><span class="p">):</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QProg</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">):</span>
        <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span> <span class="o">+</span> <span class="n">i</span><span class="p">]))</span>
    <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span><span class="p">]))</span>
    <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span><span class="p">]))</span>
    <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>

    <span class="n">cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gk_cir</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">locating_number</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iter_number</span><span class="p">):</span>
        <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cir</span><span class="p">)</span>
    <span class="c1"># print(&#39;总线路：&#39;)</span>
    <span class="c1"># pq.draw_qprog(prog)</span>
    <span class="n">result_qubit</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">):</span>
        <span class="n">result_qubit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">prob_run_dict</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">result_qubit</span><span class="p">)</span>
    <span class="c1"># print(&#39;测量结果字典：&#39;)</span>
    <span class="c1"># print(result)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>循环迭代的次数，根据论文中公式计算，发现当迭代次数为偶数次时，无法得到想要的结果，需要进行奇数化处理。</p>
<p>另外，当查询的总数较多时，根据公式计算的迭代次数过大，会错过得到结果时的次数，根据本人多次实验发现，当查找结果就1个数时，迭代次数根据公式计算后并进行奇数化，能够很大概率得到结果，但当查找结果超过1个时，该迭代次数就会错过结果。而迭代次数为5次时，基本都能得到结果，所以，当迭代次数不小于9次时，采用固定5次迭代来查询结果。</p>
<p>其代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 迭代次数计算</span>
<span class="k">def</span> <span class="nf">iter_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">estimate_count</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">estimate_count</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">estimate_count</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">estimate_count</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">9</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">-=</span> <span class="mi">4</span>
    <span class="k">return</span> <span class="n">count</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>3.10 对查询结果的索引进行处理<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p>根据线路查询的结果，得出结果索引，然后对结果索引进行处理，分离出行索引、列索引，将行、列索引作为一对数字，用元组存储到结果中。</p>
<p>其代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 结果处理</span>
<span class="k">def</span> <span class="nf">get_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">locating_number</span><span class="p">,</span> <span class="n">iter_number</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_cir</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">locating_number</span><span class="p">,</span> <span class="n">iter_number</span><span class="p">)</span>
    <span class="n">val_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">val_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="n">np_val_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val_list</span><span class="p">)</span>
    <span class="c1"># print(&#39;测量结果概率：&#39;)</span>
    <span class="c1"># print(np_val_list)</span>
    <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np_val_list</span><span class="p">)</span>
    <span class="c1"># print(&#39;查找结果概率：&#39;, max_val)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np_val_list</span> <span class="o">==</span> <span class="n">max_val</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="c1"># print(&#39;查找结果总索引：&#39;, index)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="c1"># print(&#39;-&#39; * 50)</span>
    <span class="c1"># print(&#39;行列索引结果：&#39;, result)</span>
    <span class="c1"># print(&#39;-&#39; * 50)</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># 处理总查询结果索引</span>
<span class="k">def</span> <span class="nf">get_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
        <span class="n">bin_str</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;0b&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">bin_str</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_str</span><span class="p">))</span> <span class="o">*</span> <span class="s1">&#39;0&#39;</span> <span class="o">+</span> <span class="n">bin_str</span>
        <span class="n">transaction_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_str</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction_qubit_number</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">item_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_str</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction_qubit_number</span><span class="p">:],</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">transaction_index</span><span class="p">,</span> <span class="n">item_index</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h3>3.11 找出频繁1项集<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>根据线路查询的结果，计算其支持度，并与最小支持度进行比较，得到是否满足最小支持度要求，如果满足，即可判断其是频繁项集。依次去判断每个候选项集是否为频繁项集。</p>
<p>将结果的频繁1项集用元组保存，所有结果存入一个列表中</p>
<p>将结果的频繁1项集对应的索引，和支持度存入字典中，键为频繁1项集元组，值为列表，列表第一项为索引列表，第二项为支持度。</p>
<p>其代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 根据候选1项集找频繁1项集， 候选项是列表套元组形式 [(1,), (2,), (3,), (4,)]</span>
<span class="k">def</span> <span class="nf">find_f1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">min_support</span><span class="o">=</span><span class="mf">0.4</span><span class="p">):</span>
    <span class="n">iter_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_number</span><span class="p">()</span>
    <span class="c1"># 根据量子线路，去得到每个候选1项集的行列索引</span>
    <span class="n">ck_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">c1</span><span class="p">:</span>
        <span class="n">locating_number</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">locating_number</span><span class="p">,</span> <span class="n">iter_number</span><span class="p">)</span>
        <span class="n">row_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>
        <span class="n">ck_dict</span><span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_index</span>
    <span class="c1"># 计算每个候选1项集的支持度</span>
    <span class="n">f1_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ck_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">support</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction_number</span>
        <span class="k">if</span> <span class="n">support</span> <span class="o">&gt;=</span> <span class="n">min_support</span><span class="p">:</span>
            <span class="n">f1_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="p">,</span> <span class="n">support</span><span class="p">]</span>
            <span class="n">f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f1_dict</span>
</pre></div>
</div>
</div>
<div class="section" id="kk-1">
<h3>3.12 根据频繁k项集得到频繁k+1项集<a class="headerlink" href="#kk-1" title="永久链接至标题">¶</a></h3>
<p>依据得到的频繁k项集，去得到频繁k+1项集，存储结构与频繁1项集一样</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 根据频繁k项集，去查找后面的频繁k+1项集</span>
<span class="c1"># f1_dict = {(1,): [[0, 2, 3, 4], 0.8], (2,): [[0, 2, 4], 0.6], (3,): [[0, 1, 3], 0.6]}</span>
<span class="c1"># f1 = [(1,), (2,), (3,)]</span>
<span class="k">def</span> <span class="nf">find_fk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">fk</span><span class="p">,</span> <span class="n">fk_dict</span><span class="p">,</span> <span class="n">min_support</span><span class="o">=</span><span class="mf">0.4</span><span class="p">):</span>
    <span class="n">cn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fn_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">len_fk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fk</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">len_fk</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len_fk</span><span class="p">):</span>
            <span class="c1"># 前k-1项相同时，才将两个集合合并，合并后才能生成k+1项</span>
            <span class="n">L1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fk</span><span class="p">[</span><span class="n">i</span><span class="p">])[:</span><span class="n">k</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">L2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fk</span><span class="p">[</span><span class="n">j</span><span class="p">])[:</span><span class="n">k</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">L1</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">L2</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">L1</span> <span class="o">==</span> <span class="n">L2</span><span class="p">:</span>
                <span class="c1"># 候选项</span>
                <span class="n">c</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">fk</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">|</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">fk</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="n">cn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="c1"># 频繁项索引</span>
                <span class="n">set1_index</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">fk_dict</span><span class="p">[</span><span class="n">fk</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">set2_index</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">fk_dict</span><span class="p">[</span><span class="n">fk</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>
                <span class="c1"># 频繁项索引交集</span>
                <span class="n">set_index</span> <span class="o">=</span> <span class="n">set1_index</span> <span class="o">&amp;</span> <span class="n">set2_index</span>
                <span class="n">index_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">set_index</span><span class="p">)</span>
                <span class="n">support</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_list</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction_number</span>
                <span class="k">if</span> <span class="n">support</span> <span class="o">&gt;=</span> <span class="n">min_support</span><span class="p">:</span>
                    <span class="n">fn_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">index_list</span><span class="p">,</span> <span class="n">support</span><span class="p">]</span>
                    <span class="n">fn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn_dict</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h3>3.13 统计所有频繁项集<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>根据得到的频繁1项集，和依据频繁k项集去得到频繁k+1项集，即可得到所有的频繁项集，存储结构同上</p>
<p>代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 频繁项集统计</span>
<span class="k">def</span> <span class="nf">fk_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">min_support</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="c1"># 准备候选1项集</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_c1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction_matrix</span><span class="p">)</span>
    <span class="c1"># 获得频繁1项集，频繁1项集对应交易索引和支持度</span>
    <span class="n">f1</span><span class="p">,</span> <span class="n">f1_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_f1</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">min_support</span><span class="p">)</span>

    <span class="c1"># 定义一个列表，用于存储频繁项集</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># 定义一个列表，用于存储频繁项集和索引以及支持度</span>
    <span class="n">fn_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># 根据频繁1项集，去获得后面的频繁n项集</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">fk</span> <span class="o">=</span> <span class="n">f1</span>
    <span class="n">fk_dict</span> <span class="o">=</span> <span class="n">f1_dict</span>
    <span class="k">while</span> <span class="n">fk</span><span class="p">:</span>
        <span class="n">fn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fk</span><span class="p">)</span>
        <span class="n">fn_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fk_dict</span><span class="p">)</span>
        <span class="n">fk_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_fk</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">fk</span><span class="p">,</span> <span class="n">fk_dict</span><span class="p">,</span> <span class="n">min_support</span><span class="p">)</span>
        <span class="n">fk</span> <span class="o">=</span> <span class="n">fk_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fk_dict</span> <span class="o">=</span> <span class="n">fk_result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn_dict</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h3>3.14 置信度计算<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<p>根据所有的频繁项集，去计算满足最小置信度要求的置信因果关系，结果以字典形式存储</p>
<p>其代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 置信度计算</span>
<span class="k">def</span> <span class="nf">conf_x_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">supp_xy</span><span class="p">,</span> <span class="n">supp_x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">supp_xy</span><span class="o">/</span><span class="n">supp_x</span>

<span class="c1"># 统计置信度</span>
<span class="k">def</span> <span class="nf">get_all_conf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">min_conf</span><span class="o">=</span><span class="mf">0.6</span><span class="p">):</span>
    <span class="n">fn</span><span class="p">,</span> <span class="n">fn_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fk_result</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">min_support</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
    <span class="n">len_fn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">len_fn</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">conf_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">len_fn</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">backward</span> <span class="ow">in</span> <span class="n">fn</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="c1"># 后项集合</span>
            <span class="n">set_backward</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">backward</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">forward</span> <span class="ow">in</span> <span class="n">fn</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># 前项集合</span>
                <span class="n">set_forward</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">forward</span><span class="p">)</span>
                <span class="c1"># 判断前项是否为后项的子集</span>
                <span class="k">if</span> <span class="n">set_forward</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">set_backward</span><span class="p">):</span>
                    <span class="c1"># 取出支持度</span>
                    <span class="n">supp_xy</span> <span class="o">=</span> <span class="n">fn_dict</span><span class="p">[</span><span class="n">backward</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">supp_x</span> <span class="o">=</span> <span class="n">fn_dict</span><span class="p">[</span><span class="n">forward</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># 计算可信度</span>
                    <span class="n">conf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf_x_y</span><span class="p">(</span><span class="n">supp_xy</span><span class="p">,</span> <span class="n">supp_x</span><span class="p">)</span>
                    <span class="c1"># 比较可信度</span>
                    <span class="k">if</span> <span class="n">conf</span> <span class="o">&gt;=</span> <span class="n">min_conf</span><span class="p">:</span>
                        <span class="n">cause</span> <span class="o">=</span> <span class="n">set_forward</span>
                        <span class="n">effect</span> <span class="o">=</span> <span class="n">set_backward</span> <span class="o">-</span> <span class="n">set_forward</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_conf_key</span><span class="p">(</span><span class="n">cause</span><span class="p">,</span> <span class="n">effect</span><span class="p">)</span>
                        <span class="n">conf_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">conf</span>
    <span class="k">return</span> <span class="n">conf_dict</span>

<span class="c1"># 根据数字转换为字符串，作为置信度的键</span>
<span class="k">def</span> <span class="nf">get_conf_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cause</span><span class="p">,</span> <span class="n">effect</span><span class="p">):</span>
    <span class="n">cause_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cause</span><span class="p">)</span>
    <span class="n">effect_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">effect</span><span class="p">)</span>
    <span class="n">cause_str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">items_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cause_list</span><span class="p">])</span>
    <span class="n">effect_str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">items_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">effect_list</span><span class="p">])</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">cause_str</span> <span class="o">+</span> <span class="s1">&#39;-&gt;&#39;</span> <span class="o">+</span> <span class="n">effect_str</span>
    <span class="k">return</span> <span class="n">key</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id16">
<h2>4.所有代码和测试结果<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h2>
<p>代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">量子关联规则挖掘算法，针对频繁项集进行构建</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">pyqpanda.pyQPanda</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span>


<span class="k">class</span> <span class="nc">InitQMachine</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quBitCnt</span><span class="p">,</span> <span class="n">cBitCnt</span><span class="p">,</span> <span class="n">machineType</span><span class="o">=</span><span class="n">pq</span><span class="o">.</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_machine</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">init_quantum_machine</span><span class="p">(</span><span class="n">machineType</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_qlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_machine</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="n">quBitCnt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_clist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_machine</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="n">cBitCnt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_prog</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QProg</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pq</span><span class="o">.</span><span class="n">destroy_quantum_machine</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">m_machine</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">QuantumAssociationRulesMining</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transaction_data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transaction_data</span> <span class="o">=</span> <span class="n">transaction_data</span>
        <span class="c1"># 交易信息统计</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">information</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_information</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction_data</span><span class="p">)</span>
        <span class="c1"># 交易信息条数</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transaction_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">information</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># 交易所含总项数</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">information</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># 交易所含项</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">information</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># 交易对应编码字典</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">information</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="c1"># 交易矩阵</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transaction_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">information</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="c1"># 交易所含项索引的量子比特数</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items_qubit_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_qubit_number</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 交易条数索引的量子比特数</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transaction_qubit_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_qubit_number</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction_number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 索引空间的量子比特数</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">items_qubit_number</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction_qubit_number</span>
        <span class="c1"># 数据的量子比特数</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_qubit_number</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">))</span>

    <span class="c1"># 定义获取交易数据数量，交易的项，交易的项数量</span>
    <span class="k">def</span> <span class="nf">get_information</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transaction_data</span><span class="p">):</span>
        <span class="c1"># 交易条数</span>
        <span class="n">transaction_number</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">transaction_data</span><span class="p">)</span>
        <span class="c1"># 交易所含项，集合</span>
        <span class="n">items_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">transaction_data</span><span class="p">))</span>
        <span class="c1"># 转为列表</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">items_set</span><span class="p">)</span>
        <span class="n">items</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="c1"># 交易所含项数</span>
        <span class="n">items_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
        <span class="c1"># 用数字与所含项进行对应形成字典</span>
        <span class="n">items_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">items_length</span><span class="p">)}</span>
        <span class="c1"># items数字化</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">items_length</span><span class="p">)])</span>
        <span class="c1"># 将交易信息转化为二维矩阵</span>
        <span class="n">transaction_matrix</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">transaction_data</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">temp</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">items_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                    <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">transaction_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transaction_number</span><span class="p">,</span> <span class="n">items_length</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">items_dict</span><span class="p">,</span> <span class="n">transaction_matrix</span>

    <span class="c1"># 根据项数或者交易数获取量子比特数量</span>
    <span class="k">def</span> <span class="nf">get_qubit_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># 获取候选1项集，data_set为转化后的数字交易信息，不包含0数字。返回一个list，每个元素都是tuple元 组</span>
    <span class="k">def</span> <span class="nf">create_c1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_set</span><span class="p">):</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 元素个数为1的项集（非频繁项集，因为还没有同最小支持度比较）</span>
        <span class="k">for</span> <span class="n">transaction</span> <span class="ow">in</span> <span class="n">data_set</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">transaction</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="ow">in</span> <span class="n">c1</span> <span class="ow">and</span> <span class="n">item</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">c1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">item</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">c1</span><span class="p">))</span>

    <span class="c1"># 根据当前number绘制子线路</span>
    <span class="k">def</span> <span class="nf">get_number_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">qubit_number</span><span class="p">):</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="c1"># 把当前item的数字变成二进制数字符串，并去除前面的0b字符</span>
        <span class="n">bin_str</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">number</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;0b&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="c1"># 对于不足量子比特数的前面用0进行补齐，并逆排序</span>
        <span class="n">bin_str</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">qubit_number</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_str</span><span class="p">))</span> <span class="o">*</span> <span class="s1">&#39;0&#39;</span> <span class="o">+</span> <span class="n">bin_str</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bin_str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bit</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="n">j</span><span class="p">]))</span>
        <span class="c1"># print(&#39;画子线路&#39;)</span>
        <span class="c1"># pq.draw_qprog(cir)</span>
        <span class="k">return</span> <span class="n">cir</span>

    <span class="c1"># Oracle中的 U 线路编码</span>
    <span class="k">def</span> <span class="nf">encode_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">index_qubit_number</span><span class="p">,</span> <span class="n">items_length</span><span class="p">,</span>  <span class="n">transaction_number</span><span class="p">):</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>

        <span class="c1"># 控制子线路的量子比特，对应索引空间的比特数</span>
        <span class="n">control_qubit</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index_qubit_number</span><span class="p">):</span>
            <span class="n">control_qubit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>

        <span class="c1"># 编码信息的位置</span>
        <span class="n">information_position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">index_qubit_number</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">transaction_number</span><span class="p">):</span>
            <span class="c1"># 对交易行索引量子线路进行 X 门编码</span>
            <span class="n">t_x_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">items_qubit_number</span><span class="p">,</span>
                                              <span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction_qubit_number</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span>  <span class="bp">self</span><span class="o">.</span><span class="n">transaction_qubit_number</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">items_length</span><span class="p">):</span>
                <span class="c1"># 对项列索引量子线路进行 X 门编码</span>
                <span class="n">item_x_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span> <span class="n">items_qubit_number</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">m</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">items_qubit_number</span><span class="p">)</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">item_x_cir</span><span class="p">)</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">t_x_cir</span><span class="p">)</span>
                <span class="c1"># 对此行此列数字进行编码</span>
                <span class="n">sub_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">information_position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span> <span class="n">transaction_matrix</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">m</span><span class="p">],</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span><span class="p">)</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">sub_cir</span><span class="o">.</span><span class="n">control</span><span class="p">(</span><span class="n">control_qubit</span><span class="p">))</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">t_x_cir</span><span class="p">)</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">item_x_cir</span><span class="p">)</span>

        <span class="c1"># print(&#39;U线路：&#39;)</span>
        <span class="c1"># pq.draw_qprog(cir)</span>
        <span class="k">return</span> <span class="n">cir</span>

    <span class="c1"># 定义Oracle中的查找线路 S</span>
    <span class="k">def</span> <span class="nf">query_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">target_number</span><span class="p">):</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="n">sub_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span> <span class="o">-</span>  <span class="n">target_number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span><span class="p">)</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">sub_cir</span><span class="p">)</span>
        <span class="n">control_qubit</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span><span class="p">):</span>
            <span class="n">control_qubit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span><span class="p">])</span><span class="o">.</span><span class="n">control</span><span class="p">(</span><span class="n">control_qubit</span><span class="p">))</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">sub_cir</span><span class="p">)</span>
        <span class="c1"># print(&#39;S线路：&#39;)</span>
        <span class="c1"># pq.draw_qprog(cir)</span>
        <span class="k">return</span> <span class="n">cir</span>

    <span class="c1"># 定义Oracle中的相位转移线路</span>
    <span class="k">def</span> <span class="nf">transfer_to_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">U1</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">control</span><span class="p">([</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="p">]]))</span>
        <span class="c1"># print(&#39;相位转移线路：&#39;)</span>
        <span class="c1"># pq.draw_qprog(cir)</span>
        <span class="k">return</span> <span class="n">cir</span>

    <span class="c1"># 定义oracle线路</span>
    <span class="k">def</span> <span class="nf">oracle_cir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">locating_number</span><span class="p">):</span>
        <span class="c1"># U线路</span>
        <span class="n">u_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">items_length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction_number</span><span class="p">)</span>
        <span class="c1"># S线路</span>
        <span class="n">s_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">,</span>  <span class="n">locating_number</span><span class="p">)</span>
        <span class="c1"># 相位转移线路</span>
        <span class="n">transfer_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transfer_to_phase</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span> <span class="o">+</span>  <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span><span class="p">)</span>

        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">u_cir</span><span class="p">)</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s_cir</span><span class="p">)</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">transfer_cir</span><span class="p">)</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s_cir</span><span class="o">.</span><span class="n">dagger</span><span class="p">())</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">u_cir</span><span class="o">.</span><span class="n">dagger</span><span class="p">())</span>
        <span class="c1"># print(&#39;oracle线路：&#39;)</span>
        <span class="c1"># pq.draw_qprog(cir)</span>
        <span class="k">return</span> <span class="n">cir</span>

    <span class="c1"># 定义coin线路</span>
    <span class="k">def</span> <span class="nf">coin_cir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="n">u1_position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span>
        <span class="n">swap_interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span>
        <span class="n">coin_position</span> <span class="o">=</span> <span class="n">position</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="n">control_qubit</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">):</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">coin_position</span> <span class="o">+</span> <span class="n">i</span><span class="p">]))</span>
            <span class="c1"># 变成0控</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">coin_position</span> <span class="o">+</span> <span class="n">i</span><span class="p">]))</span>
            <span class="c1"># 控制比特</span>
            <span class="n">control_qubit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">coin_position</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
        <span class="n">control_cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="c1"># 控制线路</span>
        <span class="n">control_cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">U1</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">u1_position</span><span class="p">],</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">control_cir</span><span class="o">.</span><span class="n">control</span><span class="p">(</span><span class="n">control_qubit</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">):</span>
            <span class="c1"># 控制线路还原</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">coin_position</span> <span class="o">+</span> <span class="n">i</span><span class="p">]))</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">coin_position</span> <span class="o">+</span> <span class="n">i</span><span class="p">]))</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">SWAP</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">coin_position</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span>
                            <span class="n">qlist</span><span class="p">[</span><span class="n">coin_position</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="n">swap_interval</span><span class="p">]))</span>
        <span class="c1"># print(&#39;coin 线路：&#39;)</span>
        <span class="c1"># pq.draw_qprog(cir)</span>
        <span class="k">return</span> <span class="n">cir</span>

    <span class="c1"># 定义G（k）线路</span>
    <span class="k">def</span> <span class="nf">gk_cir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">locating_number</span><span class="p">):</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="n">oracle_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oracle_cir</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">,</span>  <span class="n">locating_number</span><span class="p">)</span>
        <span class="n">coin_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coin_cir</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">oracle_cir</span><span class="p">)</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">coin_cir</span><span class="p">)</span>
        <span class="c1"># print(&#39;G(k)线路：&#39;)</span>
        <span class="c1"># pq.draw_qprog(cir)</span>
        <span class="k">return</span> <span class="n">cir</span>

    <span class="c1"># 定义循环迭代线路</span>
    <span class="k">def</span> <span class="nf">iter_cir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">locating_number</span><span class="p">,</span> <span class="n">iter_number</span><span class="p">):</span>
        <span class="n">prog</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QProg</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">):</span>
            <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span> <span class="o">+</span> <span class="n">i</span><span class="p">]))</span>
        <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span><span class="p">]))</span>
        <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span><span class="p">]))</span>
        <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span> <span class="o">+</span>  <span class="mi">1</span><span class="p">]))</span>

        <span class="n">cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gk_cir</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">locating_number</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iter_number</span><span class="p">):</span>
            <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cir</span><span class="p">)</span>
        <span class="c1"># print(&#39;总线路：&#39;)</span>
        <span class="c1"># pq.draw_qprog(prog)</span>
        <span class="n">result_qubit</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">):</span>
            <span class="n">result_qubit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">prob_run_dict</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">result_qubit</span><span class="p">)</span>
        <span class="c1"># print(&#39;测量结果字典：&#39;)</span>
        <span class="c1"># print(result)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># 迭代次数计算</span>
    <span class="k">def</span> <span class="nf">iter_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">estimate_count</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">estimate_count</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">estimate_count</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">estimate_count</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">9</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">-=</span> <span class="mi">4</span>
        <span class="k">return</span> <span class="n">count</span>

    <span class="c1"># 结果处理</span>
    <span class="k">def</span> <span class="nf">get_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">locating_number</span><span class="p">,</span> <span class="n">iter_number</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_cir</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">locating_number</span><span class="p">,</span> <span class="n">iter_number</span><span class="p">)</span>
        <span class="n">val_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">val_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">np_val_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val_list</span><span class="p">)</span>
        <span class="c1"># print(&#39;测量结果概率：&#39;)</span>
        <span class="c1"># print(np_val_list)</span>
        <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np_val_list</span><span class="p">)</span>
        <span class="c1"># print(&#39;查找结果概率：&#39;, max_val)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np_val_list</span> <span class="o">==</span> <span class="n">max_val</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># print(&#39;查找结果总索引：&#39;, index)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="c1"># print(&#39;-&#39; * 50)</span>
        <span class="c1"># print(&#39;行列索引结果：&#39;, result)</span>
        <span class="c1"># print(&#39;-&#39; * 50)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># 处理总查询结果索引</span>
    <span class="k">def</span> <span class="nf">get_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">bin_str</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;0b&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">bin_str</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_str</span><span class="p">))</span> <span class="o">*</span> <span class="s1">&#39;0&#39;</span> <span class="o">+</span> <span class="n">bin_str</span>
            <span class="n">transaction_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_str</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction_qubit_number</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">item_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_str</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction_qubit_number</span><span class="p">:],</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">transaction_index</span><span class="p">,</span> <span class="n">item_index</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># 根据候选1项集找频繁1项集， 候选项是列表套元组形式 [(1,), (2,), (3,), (4,)]</span>
    <span class="k">def</span> <span class="nf">find_f1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">min_support</span><span class="o">=</span><span class="mf">0.4</span><span class="p">):</span>
        <span class="n">iter_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_number</span><span class="p">()</span>
        <span class="c1"># 根据量子线路，去得到每个候选1项集的行列索引</span>
        <span class="n">ck_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">c1</span><span class="p">:</span>
            <span class="n">locating_number</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">locating_number</span><span class="p">,</span> <span class="n">iter_number</span><span class="p">)</span>
            <span class="n">row_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>
            <span class="n">ck_dict</span><span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_index</span>
        <span class="c1"># 计算每个候选1项集的支持度</span>
        <span class="n">f1_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ck_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">support</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction_number</span>
            <span class="k">if</span> <span class="n">support</span> <span class="o">&gt;=</span> <span class="n">min_support</span><span class="p">:</span>
                <span class="n">f1_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="p">,</span> <span class="n">support</span><span class="p">]</span>
                <span class="n">f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f1_dict</span>

    <span class="c1"># 根据频繁k项集，去查找后面的频繁k+1项集</span>
    <span class="c1"># f1_dict = {(1,): [[0, 2, 3, 4], 0.8], (2,): [[0, 2, 4], 0.6], (3,): [[0, 1, 3], 0.6]}</span>
    <span class="c1"># f1 = [(1,), (2,), (3,)]</span>
    <span class="k">def</span> <span class="nf">find_fk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">fk</span><span class="p">,</span> <span class="n">fk_dict</span><span class="p">,</span> <span class="n">min_support</span><span class="o">=</span><span class="mf">0.4</span><span class="p">):</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fn_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">len_fk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fk</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">len_fk</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len_fk</span><span class="p">):</span>
                <span class="c1"># 前k-1项相同时，才将两个集合合并，合并后才能生成k+1项</span>
                <span class="n">L1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fk</span><span class="p">[</span><span class="n">i</span><span class="p">])[:</span><span class="n">k</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">L2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fk</span><span class="p">[</span><span class="n">j</span><span class="p">])[:</span><span class="n">k</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">L1</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="n">L2</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">L1</span> <span class="o">==</span> <span class="n">L2</span><span class="p">:</span>
                    <span class="c1"># 候选项</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">fk</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">|</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">fk</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                    <span class="n">cn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="c1"># 频繁项索引</span>
                    <span class="n">set1_index</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">fk_dict</span><span class="p">[</span><span class="n">fk</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">set2_index</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">fk_dict</span><span class="p">[</span><span class="n">fk</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>
                    <span class="c1"># 频繁项索引交集</span>
                    <span class="n">set_index</span> <span class="o">=</span> <span class="n">set1_index</span> <span class="o">&amp;</span> <span class="n">set2_index</span>
                    <span class="n">index_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">set_index</span><span class="p">)</span>
                    <span class="n">support</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_list</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction_number</span>
                    <span class="k">if</span> <span class="n">support</span> <span class="o">&gt;=</span> <span class="n">min_support</span><span class="p">:</span>
                        <span class="n">fn_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">index_list</span><span class="p">,</span> <span class="n">support</span><span class="p">]</span>
                        <span class="n">fn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn_dict</span>

    <span class="c1"># 频繁项集统计</span>
    <span class="k">def</span> <span class="nf">fk_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">min_support</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="c1"># 准备候选1项集</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_c1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction_matrix</span><span class="p">)</span>
        <span class="c1"># 获得频繁1项集，频繁1项集对应交易索引和支持度</span>
        <span class="n">f1</span><span class="p">,</span> <span class="n">f1_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_f1</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">min_support</span><span class="p">)</span>

        <span class="c1"># 定义一个列表，用于存储频繁项集</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># 定义一个列表，用于存储频繁项集和索引以及支持度</span>
        <span class="n">fn_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># 根据频繁1项集，去获得后面的频繁n项集</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">fk</span> <span class="o">=</span> <span class="n">f1</span>
        <span class="n">fk_dict</span> <span class="o">=</span> <span class="n">f1_dict</span>
        <span class="k">while</span> <span class="n">fk</span><span class="p">:</span>
            <span class="n">fn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fk</span><span class="p">)</span>
            <span class="n">fn_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fk_dict</span><span class="p">)</span>
            <span class="n">fk_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_fk</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">fk</span><span class="p">,</span> <span class="n">fk_dict</span><span class="p">,</span> <span class="n">min_support</span><span class="p">)</span>
            <span class="n">fk</span> <span class="o">=</span> <span class="n">fk_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">fk_dict</span> <span class="o">=</span> <span class="n">fk_result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn_dict</span>

    <span class="c1"># 置信度计算</span>
    <span class="k">def</span> <span class="nf">conf_x_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">supp_xy</span><span class="p">,</span> <span class="n">supp_x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">supp_xy</span><span class="o">/</span><span class="n">supp_x</span>

    <span class="c1"># 统计置信度</span>
    <span class="k">def</span> <span class="nf">get_all_conf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">min_conf</span><span class="o">=</span><span class="mf">0.6</span><span class="p">):</span>
        <span class="n">fn</span><span class="p">,</span> <span class="n">fn_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fk_result</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">min_support</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
        <span class="n">len_fn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">len_fn</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">conf_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">len_fn</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">backward</span> <span class="ow">in</span> <span class="n">fn</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="c1"># 后项集合</span>
                <span class="n">set_backward</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">backward</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">forward</span> <span class="ow">in</span> <span class="n">fn</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># 前项集合</span>
                    <span class="n">set_forward</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">forward</span><span class="p">)</span>
                    <span class="c1"># 判断前项是否为后项的子集</span>
                    <span class="k">if</span> <span class="n">set_forward</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">set_backward</span><span class="p">):</span>
                        <span class="c1"># 取出支持度</span>
                        <span class="n">supp_xy</span> <span class="o">=</span> <span class="n">fn_dict</span><span class="p">[</span><span class="n">backward</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">supp_x</span> <span class="o">=</span> <span class="n">fn_dict</span><span class="p">[</span><span class="n">forward</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                        <span class="c1"># 计算可信度</span>
                        <span class="n">conf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf_x_y</span><span class="p">(</span><span class="n">supp_xy</span><span class="p">,</span> <span class="n">supp_x</span><span class="p">)</span>
                        <span class="c1"># 比较可信度</span>
                        <span class="k">if</span> <span class="n">conf</span> <span class="o">&gt;=</span> <span class="n">min_conf</span><span class="p">:</span>
                            <span class="n">cause</span> <span class="o">=</span> <span class="n">set_forward</span>
                            <span class="n">effect</span> <span class="o">=</span> <span class="n">set_backward</span> <span class="o">-</span> <span class="n">set_forward</span>
                            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_conf_key</span><span class="p">(</span><span class="n">cause</span><span class="p">,</span> <span class="n">effect</span><span class="p">)</span>
                            <span class="n">conf_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">conf</span>
        <span class="k">return</span> <span class="n">conf_dict</span>

    <span class="c1"># 根据数字转换为字符串，作为置信度的键</span>
    <span class="k">def</span> <span class="nf">get_conf_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cause</span><span class="p">,</span> <span class="n">effect</span><span class="p">):</span>
        <span class="n">cause_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cause</span><span class="p">)</span>
        <span class="n">effect_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">effect</span><span class="p">)</span>
        <span class="n">cause_str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">items_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cause_list</span><span class="p">])</span>
        <span class="n">effect_str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">items_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">effect_list</span><span class="p">])</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">cause_str</span> <span class="o">+</span> <span class="s1">&#39;-&gt;&#39;</span> <span class="o">+</span> <span class="n">effect_str</span>
        <span class="k">return</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">init_machine</span> <span class="o">=</span> <span class="n">InitQMachine</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">qlist</span> <span class="o">=</span> <span class="n">init_machine</span><span class="o">.</span><span class="n">m_qlist</span>
        <span class="n">clist</span> <span class="o">=</span> <span class="n">init_machine</span><span class="o">.</span><span class="n">m_clist</span>
        <span class="n">machine</span> <span class="o">=</span> <span class="n">init_machine</span><span class="o">.</span><span class="n">m_machine</span>

        <span class="n">position</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># locating_number = 2</span>

        <span class="c1"># iter_number = self.iter_number()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;交易信息：&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction_data</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;交易条数：&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction_number</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;项数：&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">items_length</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;项编码：&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;项索引量子比特数：&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">items_qubit_number</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;交易索引量子比特数：&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction_qubit_number</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;总索引量子比特数：&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_qubit_number</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;数据量子比特数：&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">digit_qubit_number</span><span class="p">)</span>
        <span class="c1"># self.encode_circuit(qlist, position, self.index_qubit_number, self.items_length,  self.transaction_number)</span>
        <span class="c1"># self.query_circuit(qlist, position, 3)</span>
        <span class="c1"># self.transfer_to_phase(qlist, position)</span>
        <span class="c1"># self.oracle_cir(qlist, position, locating_number)</span>
        <span class="c1"># self.coin_cir(qlist, position)</span>
        <span class="c1"># self.gk_cir(qlist, position, locating_number)</span>
        <span class="c1"># self.get_result(qlist, clist, position, locating_number, iter_number)</span>

        <span class="c1"># print(&#39;查找的数：&#39;, locating_number)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;所含项对应字典：&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">items_dict</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;交易矩阵：&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction_matrix</span><span class="p">)</span>
        <span class="c1"># print(&#39;迭代次数：&#39;, iter_number)</span>

        <span class="c1"># # 候选1项集</span>
        <span class="c1"># print(&#39;*&#39;*50)</span>
        <span class="c1"># c1 = self.create_c1(self.transaction_matrix)</span>
        <span class="c1"># print(c1)</span>

        <span class="c1"># # 频繁1项集</span>
        <span class="c1"># result = self.find_f1(qlist, clist, position, c1)</span>
        <span class="c1"># f1 = result[0]</span>
        <span class="c1"># f1_dict = result[1]</span>
        <span class="c1"># print(&#39;频繁1项集：&#39;)</span>
        <span class="c1"># print(f1)</span>
        <span class="c1"># print(&#39;频繁1项集对应的索引字典：&#39;)</span>
        <span class="c1"># print(f1_dict)</span>
        <span class="c1"># print(&#39;-&#39;*50)</span>

        <span class="c1"># # 频繁2项集</span>
        <span class="c1"># result2 = self.find_fk(2, f1, f1_dict)</span>
        <span class="c1"># f2 = result2[0]</span>
        <span class="c1"># f2_dict = result2[1]</span>
        <span class="c1"># print(&#39;频繁2项集：&#39;)</span>
        <span class="c1"># print(f2)</span>
        <span class="c1"># print(&#39;频繁2项集对应的索引字典：&#39;)</span>
        <span class="c1"># print(f2_dict)</span>

        <span class="c1"># 频繁n项集</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fk_result</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">min_support</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fn_dict</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;所有频繁项集：&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;所有频繁项集对应的索引字典：&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">fn_dict</span><span class="p">)</span>

        <span class="c1"># 置信度</span>
        <span class="n">conf_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all_conf</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;置信度：&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">conf_result</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">T0</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;面包&#39;</span><span class="p">,</span> <span class="s1">&#39;奶酪&#39;</span><span class="p">,</span> <span class="s1">&#39;牛奶&#39;</span><span class="p">]</span>
    <span class="n">T1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;面包&#39;</span><span class="p">,</span> <span class="s1">&#39;黄油&#39;</span><span class="p">]</span>
    <span class="n">T2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;奶酪&#39;</span><span class="p">,</span> <span class="s1">&#39;牛奶&#39;</span><span class="p">,</span> <span class="s1">&#39;面包&#39;</span><span class="p">]</span>
    <span class="n">T3</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;面包&#39;</span><span class="p">,</span> <span class="s1">&#39;奶酪&#39;</span><span class="p">,</span> <span class="s1">&#39;牛奶&#39;</span><span class="p">]</span>
    <span class="n">T4</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;奶酪&#39;</span><span class="p">,</span> <span class="s1">&#39;黄油&#39;</span><span class="p">,</span> <span class="s1">&#39;牛奶&#39;</span><span class="p">]</span>

    <span class="n">transaction_information</span> <span class="o">=</span> <span class="p">[</span><span class="n">T0</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">,</span> <span class="n">T4</span><span class="p">]</span>

    <span class="n">qarm</span> <span class="o">=</span> <span class="n">QuantumAssociationRulesMining</span><span class="p">(</span><span class="n">transaction_information</span><span class="p">)</span>
    <span class="n">qarm</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>测试结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>交易信息： [[&#39;面包&#39;, &#39;奶酪&#39;, &#39;牛奶&#39;], [&#39;面包&#39;, &#39;黄油&#39;], [&#39;奶酪&#39;, &#39;牛奶&#39;, &#39;面包&#39;], [&#39;面包&#39;, &#39;奶酪 &#39;, &#39;牛奶&#39;], [&#39;奶酪&#39;, &#39;黄油&#39;, &#39;牛奶&#39;]]
交易条数： 5
项数： 4
项编码： (1, 2, 3, 4)
项索引量子比特数： 2
交易索引量子比特数： 3
总索引量子比特数： 5
数据量子比特数： 3
所含项对应字典： {1: &#39;奶酪&#39;, 2: &#39;牛奶&#39;, 3: &#39;面包&#39;, 4: &#39;黄油&#39;}
交易矩阵： [[1, 2, 3, 0], [0, 0, 3, 4], [1, 2, 3, 0], [1, 2, 3, 0], [1, 2, 0, 4]]
所有频繁项集：
[[(1,), (2,), (3,), (4,)], [(1, 2), (1, 3), (2, 3)], [(1, 2, 3)]]
所有频繁项集对应的索引字典：
{(1,): [[0, 2, 3, 4], 0.8], (2,): [[0, 2, 3, 4], 0.8], (3,): [[0, 1, 2, 3], 0.8], (4,): [[1,  4], 0.4], (1, 2): [[0, 2, 3, 4], 0.8], (1, 3): [[0, 2, 3], 0.6], (2, 3): [[0, 2, 3], 0.6],  (1, 2, 3): [[0, 2, 3], 0.6]}
置信度：
奶酪-&gt;牛奶 : 1.0
牛奶-&gt;奶酪 : 1.0
奶酪-&gt;面包 : 0.7499999999999999
面包-&gt;奶酪 : 0.7499999999999999
牛奶-&gt;面包 : 0.7499999999999999
面包-&gt;牛奶 : 0.7499999999999999
奶酪,牛奶-&gt;面包 : 0.7499999999999999
奶酪,面包-&gt;牛奶 : 1.0
牛奶,面包-&gt;奶酪 : 1.0
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h2>5.总结<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<p>通过量子与经典混合计算，可以得到关联规则挖掘的频繁项集和简单的推荐依据的置信度。</p>
<p>经过以上流程，并经过一些数据的测试和验证，该方案可以实现关联规则挖掘的频繁项集统计以及置信度的计算。</p>
<p>该方案量子线路部分的核心思想采用量子行走搜索方式，并在此基础上进行二维索引编码升级方式来适应关联规则问题。</p>
<p>利用量子线路部分去统计每个候选1项集对应搜索结果索引，然后计算其支持度，来得到频繁1项集，然后采用该结果去迭代频繁n项集，得到所有的频繁项集，最后根据频繁项集计算置信度并给出结果。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="chapter2.html" class="btn btn-neutral float-right" title="QSVM说明文档" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../index.html" class="btn btn-neutral" title="QML用户手册" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, bylz

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>