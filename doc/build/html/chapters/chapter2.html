

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>QSVM说明文档 &mdash; QML用户手册 0.1.1 文档</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="prev" title="QARM说明文档" href="chapter1.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> QML用户手册
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="chapter1.html">QARM说明文档</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">QSVM说明文档</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#svm">1.SVM简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">2.QSVM解决的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">3.实现步骤</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">3.1内积的计算</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hhlbalpha">3.2基于HHL算法的求解b和alpha问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">3.3分类</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">4.总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QML用户手册</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>QSVM说明文档</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/chapters/chapter2.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="qsvm">
<h1>QSVM说明文档<a class="headerlink" href="#qsvm" title="永久链接至标题">¶</a></h1>
<p><strong>version：3.0</strong></p>
<p><strong>Author：李蕾</strong></p>
<p><strong>Update Date：20200519</strong></p>
<div class="section" id="svm">
<h2>1.SVM简介<a class="headerlink" href="#svm" title="永久链接至标题">¶</a></h2>
<p>机器学习算法可以简单的分为两类：非监督学习和监督学习，两者的主要区别在于前者事先不知道样本的标签，而后者事先已经知道样本的标签。同样，算法可以用于求解回归问题（输出的是连续数据类型），也可以用于求解分类问题（输出的数据类型是离散数据）。SVM属于用于分类问题的监督学习算法。当然SVM也可以用于回归问题。</p>
<p>如下所示，给出一组训练样本，根据样本去找最大间隔超平面</p>
<img alt="../_images/002SVM.png" class="align-center" src="../_images/002SVM.png" />
<p>SVM利用了少数的支持向量，通过一个分类超平面将数据分为两类，使这两类之间的间隔最大化，因此它也被称为最大间隔分类器。如图所示，超平面将实心圆和空心圆两类元素进行分类，使两类之间的距离达到最大，处于虚线上的点称为支持向量。</p>
<p>这里重点记录两个变量，<strong>法向量w</strong> 和 <strong>偏移量b</strong>，它们是决定这个超平面的参数。</p>
<img alt="../_images/001分类.png" class="align-center" src="../_images/001分类.png" />
<p>一个支持向量机通过线性可分器实现。目标是寻找到一个超平面能够最好的区分两类数据，并且提供了一个决策边界供后续的分类任务。一个简单的例子是一个一维的线性数据，在点x的两边的数据分别属于类1和类2。在多维的情况下，一个超平面作为边界，在超平面一侧的数据属于一类，在超平面另一侧的数据属于另一类。图中给出的是一个二维的情况。对于线性不可分的情况，可以通过映射实现低维度到高维度的转换，使其变成线性可分。</p>
<p>SVM结构如下所示，其中最关键的两个问题分别是内积的计算和和找到最优的alpha。</p>
<img alt="../_images/003SVM结构.png" class="align-center" src="../_images/003SVM结构.png" />
</div>
<div class="section" id="id1">
<h2>2.QSVM解决的问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>虽然SVM只利用了少量的支持向量，但在计算上还是遍历了所有的样本和所有的特性，因此时间复杂度是**特征数量N**以及**样本数量M**的多项式级。当样本数量很大，比如达到TB(2^40^)和PB(2^50^)级，计算量是相当大的。</p>
<p>在大数据的背景下，量子算法能够提供一个指数级的加速，就像经典中处理1TB的数量，在量子中只要40个量子比特的数量级就可以了。</p>
<p>在2014年MIT和GOOGLE研究所联合发表在PRL的Quantum Support Vector Machine for Big Data Classification这篇文章中，介绍了基于HHL算法的QSVM的实现方法。如下图所示，通过两个量子方法解决了SVM中涉及的两个参数的计算复杂度问题。</p>
<img alt="../_images/004HHLsvm.png" class="align-center" src="../_images/004HHLsvm.png" />
<p>问题1是内积的计算问题，通过SWAP-test实现，问题2是一个基于HHL算法的求解线性方程问题。</p>
</div>
<div class="section" id="id2">
<h2>3.实现步骤<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<div class="section" id="id3">
<h3>3.1内积的计算<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>在求解原始的SVM算法时，会将原始问题中对前面提到的参数w和b的求解，通过拉格朗日对偶及KKT条件转换为对拉格朗日乘子alpha的求解，最终通过带入alpha得到原始问题的解w和b。</p>
<p>在求解alpha时，会涉及到核函数，也就是样本之间的内积操作。经典算法复杂度是O(N)，量子的swap test方法可以达到O(logN)</p>
<p>量子线路如下所示</p>
<img alt="../_images/005SWAP-test.png" class="align-center" src="../_images/005SWAP-test.png" />
<p>其过程如下：</p>
<p>经过第一个H门后的态：<span class="math notranslate nohighlight">\(\left|\psi_{1}\right\rangle=\frac{1}{\sqrt{2}}(|0, a, b\rangle+|1, a, b\rangle)\)</span></p>
<p>经过受控交换门后的态：<span class="math notranslate nohighlight">\(\left|\psi_{2}\right\rangle=\frac{1}{\sqrt{2}}(|0, a, b\rangle+|1, b, a\rangle)\)</span></p>
<p>经过第二个H门后的态：<span class="math notranslate nohighlight">\(\left|\psi_{3}\right\rangle=\frac{1}{2}|0\rangle(|a, b\rangle+|b, a\rangle)+\frac{1}{2}|1\rangle(|a, b\rangle-|b, a\rangle)\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}P(|0\rangle) &amp;=\left|\left\langle 0 | \psi_{3}\right\rangle\right|^{2} \\&amp;=\left|\frac{1}{2}\langle 0 | 0\rangle(|a, b\rangle+|b, a\rangle)+\frac{1}{2}\langle 0 | 1\rangle(|a, b\rangle-|b, a\rangle)\right|^{2} \\&amp;=\frac{1}{4}|(|a, b\rangle+|b, a\rangle)|^{2} \\&amp;=\frac{1}{4}(\langle b | b\rangle\langle a | a\rangle+\langle b | a\rangle\langle a | b\rangle+\langle a | b\rangle\langle b | a\rangle+\langle a | a\rangle\langle b | b\rangle) \\&amp;=\frac{1}{2}+\frac{1}{2}|\langle a | b\rangle|^{2}\end{aligned}\end{split}\]</div>
<p>通过测量的结果，去反求出内积。</p>
<p>根据此线路使用python进行代码实现</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyqpanda.pyQPanda</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="k">class</span> <span class="nc">InitQMachine</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quBitCnt</span><span class="p">,</span> <span class="n">cBitCnt</span><span class="p">,</span> <span class="n">machineType</span><span class="o">=</span><span class="n">pq</span><span class="o">.</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_machine</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">init_quantum_machine</span><span class="p">(</span><span class="n">machineType</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_qlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_machine</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="n">quBitCnt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_clist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_machine</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="n">cBitCnt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_prog</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QProg</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pq</span><span class="o">.</span><span class="n">destroy_quantum_machine</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">m_machine</span><span class="p">))</span>

<span class="n">init_machine</span> <span class="o">=</span> <span class="n">InitQMachine</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">qlist</span> <span class="o">=</span> <span class="n">init_machine</span><span class="o">.</span><span class="n">m_qlist</span>
<span class="n">clist</span> <span class="o">=</span> <span class="n">init_machine</span><span class="o">.</span><span class="n">m_clist</span>
<span class="n">machine</span> <span class="o">=</span> <span class="n">init_machine</span><span class="o">.</span><span class="n">m_machine</span>


<span class="c1"># 将输入的特征值进行归一化</span>
<span class="k">def</span> <span class="nf">input_normalize</span><span class="p">(</span><span class="n">vector_x</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vector_x</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0000001</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>


<span class="c1"># 构造量子线路SWAP-test</span>
<span class="k">def</span> <span class="nf">construct_qcircuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QProg</span><span class="p">()</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">CreateEmptyCircuit</span><span class="p">()</span>
    <span class="n">swap_circuit</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">SWAP</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>\
        <span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">initial_state</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">))</span>\
        <span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">initial_state</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">))</span>\
        <span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">swap_circuit</span><span class="o">.</span><span class="n">control</span><span class="p">([</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>\
        <span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="c1"># prog.insert(circuit).insert(Measure(q[0], c[0]))</span>
    <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>

    <span class="c1"># print(&#39;draw_qprog:&#39;)</span>
    <span class="c1"># pq.draw_qprog(prog)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">prob_run_dict</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># result = run_with_configuration(prog, c, 10000)</span>

    <span class="c1"># print(result)</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">p0</span>


<span class="c1"># 制备量子态，将特征向量通过制备线路变成量子态</span>
<span class="k">def</span> <span class="nf">initial_state</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">qcir</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>
    <span class="n">theata</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">qcir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">RY</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">theata</span><span class="p">))</span>
    <span class="c1"># print(&#39;draw_qprog:&#39;)</span>
    <span class="c1"># pq.draw_qprog(qcir)</span>

    <span class="k">return</span> <span class="n">qcir</span>


<span class="c1"># 计算内积</span>
<span class="k">def</span> <span class="nf">cal_inner_product</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># 将x进行归一化</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">input_normalize</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># print(&#39;归一化后的x：&#39;, x)</span>
    <span class="c1"># 定义列表用于存储测量概率幅的结果</span>
    <span class="n">p0_matrix</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">construct_qcircuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">clist</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
        <span class="n">p0_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p0_matrix</span>


<span class="c1"># 计算核矩阵</span>
<span class="k">def</span> <span class="nf">get_kernel_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">cal_inner_product</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
    <span class="c1"># print(&#39;测量概率：&#39;)</span>
    <span class="c1"># print(p0)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">p0</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="c1"># print(idx)</span>
    <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">p0</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.00000000001</span>

    <span class="c1"># print(&#39;测量概率：&#39;)</span>
    <span class="c1"># print(p0)</span>
    <span class="n">kernel_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p0</span><span class="o">*</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kernel_matrix</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="n">x</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">14</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">52</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">]]</span>
    <span class="c1"># x = [[4.01, 0.], [0.,   1.4], [1.12, 1.93]]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">get_kernel_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;核矩阵：&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="n">norm_x</span> <span class="o">=</span> <span class="n">input_normalize</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">norm_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">norm_x</span><span class="p">,</span> <span class="n">norm_x</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;计算得到的内积：&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">norm_x</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">norm_x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="hhlbalpha">
<h3>3.2基于HHL算法的求解b和alpha问题<a class="headerlink" href="#hhlbalpha" title="永久链接至标题">¶</a></h3>
<p>求得内积后就是求解alpha，解alpha是一个二次规划的问题，文章《Quantum support vector machine for big data classification》并没有对原始SVM进行分析，而是对最小二乘支持向量机LSSVM的求解进行了分析。其是基于HHL算法进行实现的。</p>
<img alt="../_images/006LSSVM.png" class="align-center" src="../_images/006LSSVM.png" />
<p>LSSVM通过引入松弛变量e_j，将原来SVM的不等式约束转换为等式约束，大大方便了拉格朗日参数alpha的求解，将原来的QP（Quadratic Programming二次规划）问题转换为求解线性方程组的问题。量子算法在求解线性方程组时能够达到指数级的加速，因此可以用于对LSSVM的求解。</p>
<p>首先是HHL线路图如下所示：</p>
<img alt="../_images/007HHL.png" class="align-center" src="../_images/007HHL.png" />
<p>第一步：</p>
<p>输入寄存器的量子态 <span class="math notranslate nohighlight">\(|\tilde y\rangle = \sum\limits_{j=1}^{M+1}\langle u_j|\tilde y\rangle|u_j\rangle\)</span> ，其中 <span class="math notranslate nohighlight">\(|u_j\rangle\)</span> 为 <span class="math notranslate nohighlight">\(\hat F\)</span> 的特征值 <span class="math notranslate nohighlight">\(\lambda_j\)</span> 对应的特征态，其中 <span class="math notranslate nohighlight">\(\hat F = F/trF\)</span> 且 <span class="math notranslate nohighlight">\(||F||\leq 1\)</span> ，<span class="math notranslate nohighlight">\(\hat F = (J+K+\gamma^{-1}1)/trF\)</span> ，其中 <span class="math notranslate nohighlight">\(J=\pmatrix{0 &amp; \vec 1^T \\ \vec 1 &amp; 0}\)</span> 。</p>
<p>首先实现任意矩阵的RY旋转角度编码，其代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">目标：实现任意矩阵的量子态振幅编码线路</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>


<span class="c1"># 对数据进行增补</span>
<span class="k">def</span> <span class="nf">_preprocessing</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="n">vector</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">flat</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">number_zero</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">n</span> <span class="o">-</span> <span class="n">length</span>
    <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">number_zero</span><span class="p">)</span>
    <span class="c1"># 针对不够2的n次方个数的矩阵，进行补零</span>
    <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">zeros</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vector</span>


<span class="c1"># 对向量进行分组</span>
<span class="k">def</span> <span class="nf">_queue_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="c1"># vector：预处理后的vector</span>
<span class="k">def</span> <span class="nf">_get_theata</span><span class="p">(</span><span class="n">vector_list</span><span class="p">):</span>

    <span class="n">theata_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">vector_list</span><span class="p">:</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[:</span><span class="n">length</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="n">length</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">left_sum</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">fsum</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_sum</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">fsum</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">left_sum</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">right_sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">theata</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">theata</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">left_sum</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">left_sum</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">right_sum</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theata</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">:</span>
            <span class="n">theata_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">theata_list</span>


<span class="c1"># 对矩阵进行振幅编码，得到结果，形如</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">[</span>
<span class="sd">[2.33],</span>
<span class="sd">[2.40, 1.57],</span>
<span class="sd">[2.33, 1.87, 1.76, 1.01],</span>
<span class="sd">[2.21, 1.85, 1.75, 1.70, 1.67, 1.65, 1.64, 0.0]</span>
<span class="sd">]</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="k">def</span> <span class="nf">encode_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_preprocessing</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">_queue_vector</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># print(q)</span>
    <span class="n">theatas</span> <span class="o">=</span> <span class="n">_get_theata</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">theatas</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">theatas</span> <span class="o">=</span> <span class="n">encode_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">theatas</span><span class="p">)</span>
</pre></div>
</div>
<p>然后根据得到的RY旋转角度，构建量子线路，其代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 振幅编码</span>
<span class="k">def</span> <span class="nf">prepare_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="c1"># 准备RY旋转角度矩阵</span>
    <span class="n">theata_list</span> <span class="o">=</span> <span class="n">encode_matrix</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="c1"># 构建线路</span>
    <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="n">control_position</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">theatas</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">theata_list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">theata</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">theatas</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">RY</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="o">+</span><span class="n">i</span><span class="p">],</span> <span class="n">theata</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gate</span> <span class="o">=</span> <span class="n">RY</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span> <span class="n">theata</span><span class="p">)</span>
                <span class="c1"># 对当前的索引进行编码</span>
                <span class="n">temp_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="c1"># 插入索引</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">temp_cir</span><span class="p">)</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">gate</span><span class="o">.</span><span class="n">control</span><span class="p">(</span><span class="n">control_position</span><span class="p">))</span>
                <span class="c1"># 还原</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">temp_cir</span><span class="p">)</span>
        <span class="n">control_position</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="o">+</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># print(&#39;draw_input_circuit:&#39;)</span>
    <span class="c1"># pq.draw_qprog(cir)</span>

    <span class="k">return</span> <span class="n">cir</span>
</pre></div>
</div>
<p>第二步：</p>
<p>实现相位估计Phase Estimation</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 相位估计，qlist为量子寄存器，position表示构建线路的位置，number表示相位估计的clock寄存器的数量</span>
<span class="k">def</span> <span class="nf">phase_estimation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
    <span class="n">cir</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>

    <span class="c1"># clock量子比特位置</span>
    <span class="n">clock_position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">clock_position</span> <span class="o">+</span> <span class="n">i</span><span class="p">]))</span>

    <span class="c1"># 矩阵分解部分的子线路</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
        <span class="c1"># 矩阵酉化, 处理成一个一维的向量，作为matrix_decompose的参数</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm_F</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">16</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">)</span>
        <span class="c1"># 矩阵分解线路</span>
        <span class="n">temp_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_decompose</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">temp_cir</span><span class="o">.</span><span class="n">control</span><span class="p">([</span><span class="n">qlist</span><span class="p">[</span><span class="n">clock_position</span><span class="o">+</span><span class="n">i</span><span class="p">]]))</span>

    <span class="c1"># 量子傅里叶变换</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">clock_position</span><span class="o">+</span><span class="n">number</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">CR</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">clock_position</span><span class="o">+</span><span class="n">number</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">j</span><span class="p">],</span> <span class="n">qlist</span><span class="p">[</span><span class="n">clock_position</span><span class="o">+</span><span class="n">number</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>

    <span class="c1"># print(&#39;draw_phase_estimation:&#39;)</span>
    <span class="c1"># pq.draw_qprog(cir)</span>

    <span class="k">return</span> <span class="n">cir</span>
</pre></div>
</div>
<p>【1】模拟 <span class="math notranslate nohighlight">\(e^{-i\hat{F}\Delta{t}}\)</span> 对于算法第二步的输入，模拟 <span class="math notranslate nohighlight">\(e^{-i\hat{F}\Delta{t}}\)</span> 的核心是模拟 <span class="math notranslate nohighlight">\(K∕trK\)</span> 。</p>
<p>其中的难点是构造 <span class="math notranslate nohighlight">\(e^{-i\hat{F}\Delta{t}} = e^{-i\Delta{t}1/trF}e^{-iJ\Delta{t}/trF}e^{-iK\Delta{t}/trF} + o(\Delta t^2)\)</span> 。</p>
<img alt="../_images/010EIFT.png" class="align-center" src="../_images/010EIFT.png" />
<p>【2】模拟 <span class="math notranslate nohighlight">\(\hat K=K/trK\)</span> ：这一步核心操作可以通过约化密度算子来实现，也就是通过对密度算子求偏迹运算得到。</p>
<img alt="../_images/011KtrK.png" class="align-center" src="../_images/011KtrK.png" />
<p>【3】模拟 <span class="math notranslate nohighlight">\(e^{-i\hat{K}\Delta{t}}\)</span> ：如果K ̂是稀疏的，可以有效的模拟。在 <span class="math notranslate nohighlight">\(\hat K\)</span> 为非稀疏矩阵时，QPCA《Quatum principal component analysis》这篇论文中提供了一种对非稀疏对称或厄密矩阵的有效模拟方法。</p>
<img alt="../_images/012eiKt.png" class="align-center" src="../_images/012eiKt.png" />
<p>通过以上几步的拆分最终可以实现 <span class="math notranslate nohighlight">\(e^{-i\hat{F}\Delta{t}}\)</span> 的有效模拟。</p>
<p>其公式他推导过程如下：</p>
<img alt="../_images/012公式推导1.png" class="align-center" src="../_images/012公式推导1.png" />
<img alt="../_images/013公式推导2.png" class="align-center" src="../_images/013公式推导2.png" />
<p>该过程的是一个矩阵分解的操作，其实现过程已经有C++代码实现，调用其接口即可，下面给出python调用该接口实现分解功能的代码。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 将矩阵进行分解</span>
<span class="k">def</span> <span class="nf">matrix_decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="c1"># print(matrix)</span>
    <span class="c1"># 获取分解矩阵的作用比特位置</span>
    <span class="n">qubit_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
        <span class="n">qubit_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
    <span class="c1"># 获取分解线路</span>
    <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">matrix_decompose</span><span class="p">(</span><span class="n">qubit_list</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>

    <span class="c1"># print(&#39;矩阵分解：&#39;)</span>
    <span class="c1"># pq.draw_qprog(cir)</span>

    <span class="k">return</span> <span class="n">cir</span>
</pre></div>
</div>
<p>第三步：</p>
<p>受控旋转control-rotation</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 受控旋转</span>
<span class="k">def</span> <span class="nf">control_rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
    <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
        <span class="n">gate</span> <span class="o">=</span> <span class="n">RY</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="o">+</span><span class="n">number</span><span class="p">],</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">)</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">gate</span><span class="o">.</span><span class="n">control</span><span class="p">([</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="n">i</span><span class="p">]]))</span>

    <span class="c1"># print(&#39;draw_control_rotate:&#39;)</span>
    <span class="c1"># pq.draw_qprog(cir)</span>

    <span class="k">return</span> <span class="n">cir</span>
</pre></div>
</div>
<p>第四步：</p>
<p>振幅放大，通过此将 <span class="math notranslate nohighlight">\(|1\rangle\)</span> 态的幅值放大，提高测量的成功率，目前该步暂时不用，直接去进行测量得到结果。</p>
<p>第五步：</p>
<p>测量最后一个量子位，如果结果是 <span class="math notranslate nohighlight">\(|1\rangle\)</span> ，则输入比特的输出就是需要的结果 <span class="math notranslate nohighlight">\(|b,\vec\alpha\rangle = \frac{1}{\sqrt C}(b|0\rangle + \sum\limits_{k=1}^M\alpha_k|k\rangle)\)</span></p>
<p>综合以上所有过程，整体代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">HHL算法</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">pyqpanda.pyQPanda</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="k">import</span> <span class="n">expm</span>
<span class="kn">from</span> <span class="nn">swap_test</span> <span class="k">import</span> <span class="n">get_kernel_matrix</span>
<span class="kn">from</span> <span class="nn">encode_on_matrix</span> <span class="k">import</span> <span class="n">encode_matrix</span>


<span class="k">class</span> <span class="nc">InitQMachine</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quBitCnt</span><span class="p">,</span> <span class="n">cBitCnt</span><span class="p">,</span> <span class="n">machineType</span><span class="o">=</span><span class="n">pq</span><span class="o">.</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_machine</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">init_quantum_machine</span><span class="p">(</span><span class="n">machineType</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_machine</span><span class="o">.</span><span class="n">set_configure</span><span class="p">(</span><span class="mi">35</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_qlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_machine</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="n">quBitCnt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_clist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_machine</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="n">cBitCnt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_prog</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QProg</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pq</span><span class="o">.</span><span class="n">destroy_quantum_machine</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">m_machine</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">HHL</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="c1"># 核矩阵</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_kernel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># 数据的数量</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># 输入线路数据的数量</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># F矩阵</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_F_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>
        <span class="c1"># 归一化后的 F矩阵</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">)</span>
        <span class="c1"># 归一化F矩阵的特征值，和特征向量</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalue</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues_of_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm_F</span><span class="p">)</span>
        <span class="c1"># HHL输入量子比特数</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c1"># HHL输入参数值</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># 获取核矩阵</span>
    <span class="k">def</span> <span class="nf">get_kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">get_kernel_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">k</span>

    <span class="c1"># 获取F矩阵</span>
    <span class="k">def</span> <span class="nf">get_F_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">ones_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">first_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">first_line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">ones_col</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">((</span><span class="n">first_line</span><span class="p">,</span> <span class="n">F</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">F</span>

    <span class="c1"># 矩阵的特征值,和特征向量</span>
    <span class="k">def</span> <span class="nf">eigenvalues_of_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvector</span>

    <span class="c1"># 矩阵的迹</span>
    <span class="k">def</span> <span class="nf">trace_of_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span><span class="p">(</span><span class="s2">&quot;matrix must be a square matrix&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>

    <span class="c1"># 矩阵的归一化</span>
    <span class="k">def</span> <span class="nf">normalize_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_of_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">matrix</span><span class="o">/</span><span class="n">trace</span>

    <span class="c1"># 计算matrix转置共轭矩阵</span>
    <span class="k">def</span> <span class="nf">transposed_conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_matrix</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">target_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="c1"># 定义判断矩阵是否是酉矩阵</span>
    <span class="k">def</span> <span class="nf">is_unitary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_matrix</span><span class="p">):</span>
        <span class="n">trans_conj_of_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transposed_conjugate</span><span class="p">(</span><span class="n">target_matrix</span><span class="p">)</span>
        <span class="n">product</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_matrix</span><span class="p">,</span> <span class="n">trans_conj_of_matrix</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">ones_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">product</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">product</span> <span class="o">==</span> <span class="n">ones_matrix</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># 将matrix进行酉化</span>
    <span class="k">def</span> <span class="nf">unitary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">t0</span><span class="p">):</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="c1"># print(matrix)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">matrix</span>
        <span class="k">return</span> <span class="n">expm</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">matrix</span> <span class="o">*</span> <span class="n">t0</span><span class="p">)</span>

    <span class="c1"># 根据当前number绘制子线路</span>
    <span class="k">def</span> <span class="nf">get_number_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">qubit_number</span><span class="p">):</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="c1"># 把当前item的数字变成二进制数字符串，并去除前面的0b字符</span>
        <span class="n">bin_str</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">number</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;0b&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="c1"># 对于不足量子比特数的前面用0进行补齐，并逆排序</span>
        <span class="n">bin_str</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">qubit_number</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_str</span><span class="p">))</span> <span class="o">*</span> <span class="s1">&#39;0&#39;</span> <span class="o">+</span> <span class="n">bin_str</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bin_str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bit</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="n">j</span><span class="p">]))</span>

        <span class="c1"># print(&#39;画子线路&#39;)</span>
        <span class="c1"># pq.draw_qprog(cir)</span>

        <span class="k">return</span> <span class="n">cir</span>

    <span class="c1"># 振幅编码</span>
    <span class="k">def</span> <span class="nf">prepare_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># 准备RY旋转角度矩阵</span>
        <span class="n">theata_list</span> <span class="o">=</span> <span class="n">encode_matrix</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="c1"># 构建线路</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="n">control_position</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">theatas</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">theata_list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">theata</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">theatas</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">RY</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="o">+</span><span class="n">i</span><span class="p">],</span> <span class="n">theata</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gate</span> <span class="o">=</span> <span class="n">RY</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span> <span class="n">theata</span><span class="p">)</span>
                    <span class="c1"># 对当前的索引进行编码</span>
                    <span class="n">temp_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="c1"># 插入索引</span>
                    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">temp_cir</span><span class="p">)</span>
                    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">gate</span><span class="o">.</span><span class="n">control</span><span class="p">(</span><span class="n">control_position</span><span class="p">))</span>
                    <span class="c1"># 还原</span>
                    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">temp_cir</span><span class="p">)</span>
            <span class="n">control_position</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="o">+</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># print(&#39;draw_input_circuit:&#39;)</span>
        <span class="c1"># pq.draw_qprog(cir)</span>

        <span class="k">return</span> <span class="n">cir</span>

    <span class="c1"># 将矩阵进行分解</span>
    <span class="k">def</span> <span class="nf">matrix_decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># print(matrix)</span>
        <span class="c1"># 获取分解矩阵的作用比特位置</span>
        <span class="n">qubit_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="n">qubit_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
        <span class="c1"># 获取分解线路</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">matrix_decompose</span><span class="p">(</span><span class="n">qubit_list</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>

        <span class="c1"># print(&#39;矩阵分解：&#39;)</span>
        <span class="c1"># pq.draw_qprog(cir)</span>

        <span class="k">return</span> <span class="n">cir</span>

    <span class="c1"># 相位估计，qlist为量子寄存器，position表示构建线路的位置，number表示相位估计的clock寄存器的数量</span>
    <span class="k">def</span> <span class="nf">phase_estimation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>

        <span class="c1"># clock量子比特位置</span>
        <span class="n">clock_position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">clock_position</span> <span class="o">+</span> <span class="n">i</span><span class="p">]))</span>

        <span class="c1"># 矩阵分解部分的子线路</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
            <span class="c1"># 矩阵酉化, 处理成一个一维的向量，作为matrix_decompose的参数</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm_F</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">16</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">)</span>
            <span class="c1"># 矩阵分解线路</span>
            <span class="n">temp_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_decompose</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">temp_cir</span><span class="o">.</span><span class="n">control</span><span class="p">([</span><span class="n">qlist</span><span class="p">[</span><span class="n">clock_position</span><span class="o">+</span><span class="n">i</span><span class="p">]]))</span>

        <span class="c1"># 量子傅里叶变换</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">clock_position</span><span class="o">+</span><span class="n">number</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">CR</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">clock_position</span><span class="o">+</span><span class="n">number</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">j</span><span class="p">],</span> <span class="n">qlist</span><span class="p">[</span><span class="n">clock_position</span><span class="o">+</span><span class="n">number</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># print(&#39;draw_phase_estimation:&#39;)</span>
        <span class="c1"># pq.draw_qprog(cir)</span>

        <span class="k">return</span> <span class="n">cir</span>

    <span class="c1"># 受控旋转</span>
    <span class="k">def</span> <span class="nf">control_rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
            <span class="n">gate</span> <span class="o">=</span> <span class="n">RY</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="o">+</span><span class="n">number</span><span class="p">],</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">)</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">gate</span><span class="o">.</span><span class="n">control</span><span class="p">([</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="n">i</span><span class="p">]]))</span>

        <span class="c1"># print(&#39;draw_control_rotate:&#39;)</span>
        <span class="c1"># pq.draw_qprog(cir)</span>

        <span class="k">return</span> <span class="n">cir</span>

    <span class="c1"># 构建 HHL 线路</span>
    <span class="k">def</span> <span class="nf">hhl_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">clock_number</span><span class="p">):</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>

        <span class="n">pe_position</span> <span class="o">=</span> <span class="n">position</span>
        <span class="n">cr_position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="c1"># 相位估计线路</span>
        <span class="n">phase_estimation_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_estimation</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">pe_position</span><span class="p">,</span> <span class="n">clock_number</span><span class="p">)</span>
        <span class="c1"># 受控旋转线路</span>
        <span class="n">control_rotate_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_rotate</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">cr_position</span><span class="p">,</span> <span class="n">clock_number</span><span class="p">)</span>

        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">phase_estimation_cir</span><span class="p">)</span> \
            <span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">control_rotate_cir</span><span class="p">)</span> \
            <span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">phase_estimation_cir</span><span class="o">.</span><span class="n">dagger</span><span class="p">())</span>

        <span class="c1"># print(&#39;draw_qprog:&#39;)</span>
        <span class="c1"># pq.draw_qprog(cir)</span>

        <span class="k">return</span> <span class="n">cir</span>

    <span class="c1"># 带输入量子编码的 HHL线路, 并进行求解 |b, a&gt;</span>
    <span class="k">def</span> <span class="nf">solve_hhl_cir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">clock_number</span><span class="p">,</span> <span class="n">input_values</span><span class="p">):</span>
        <span class="c1"># 输入编码线路</span>
        <span class="n">input_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_state</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">input_values</span><span class="p">)</span>
        <span class="c1"># HHL线路</span>
        <span class="n">hhl_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hhl_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">clock_number</span><span class="p">)</span>
        <span class="n">prog</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QProg</span><span class="p">()</span>
        <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">input_cir</span><span class="p">)</span>
        <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">hhl_cir</span><span class="p">)</span>

        <span class="c1"># print(&#39;draw_qprog:&#39;)</span>
        <span class="c1"># pq.draw_qprog(prog)</span>

        <span class="n">directly_run</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span>
        <span class="n">full_state</span> <span class="o">=</span> <span class="n">get_qstate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">full_state</span>

    <span class="c1"># 筛选出辅助比特测量结果是 1的态</span>
    <span class="k">def</span> <span class="nf">postselect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statevector</span><span class="p">,</span> <span class="n">qubit_index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">qubit_index</span>
        <span class="c1"># print(&#39;mask:&#39;)</span>
        <span class="c1"># print(mask)</span>
        <span class="c1"># print(&#39;statevector:&#39;)</span>
        <span class="c1"># print(statevector)</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
            <span class="n">array_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">statevector</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">mask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">array_mask</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">statevector</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>

        <span class="c1"># print(&#39;array_mask:&#39;)</span>
        <span class="c1"># print(array_mask)</span>

        <span class="k">def</span> <span class="nf">normalise</span><span class="p">(</span><span class="n">vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="k">import</span> <span class="n">norm</span>
            <span class="k">return</span> <span class="n">vec</span> <span class="o">/</span> <span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">normalise</span><span class="p">(</span><span class="n">statevector</span><span class="p">[</span><span class="n">array_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>

    <span class="c1"># 近似运算</span>
    <span class="k">def</span> <span class="nf">round_to_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">2e-15</span><span class="p">):</span>
        <span class="n">vec</span><span class="o">.</span><span class="n">real</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">vec</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">vec</span><span class="o">.</span><span class="n">imag</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">vec</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">vec</span>

    <span class="c1"># 计算结果</span>
    <span class="k">def</span> <span class="nf">get_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">):</span>
        <span class="n">full_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solve_hhl_cir</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_y</span><span class="p">))</span>
        <span class="n">statevector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round_to_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postselect</span><span class="p">(</span><span class="n">full_state</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="mf">1e-3</span><span class="p">)</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">statevector</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">solution</span><span class="o">.</span><span class="n">real</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">init_machine</span> <span class="o">=</span> <span class="n">InitQMachine</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
        <span class="n">qlist</span> <span class="o">=</span> <span class="n">init_machine</span><span class="o">.</span><span class="n">m_qlist</span>
        <span class="n">clist</span> <span class="o">=</span> <span class="n">init_machine</span><span class="o">.</span><span class="n">m_clist</span>
        <span class="n">machine</span> <span class="o">=</span> <span class="n">init_machine</span><span class="o">.</span><span class="n">m_machine</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;HHL输入的向量：&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_y</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;核矩阵：&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;F矩阵：&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;归一化后的F矩阵：&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm_F</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;特征值：&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalue</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;特征向量：&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvector</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;数据的数量：&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>

        <span class="c1"># 根据数字进行二进制编码，绘制线路</span>
        <span class="c1"># self.get_number_circuit(qlist, 0, 0, 2)</span>

        <span class="c1"># 振幅编码</span>
        <span class="c1"># l = [i for i in range(15)]</span>
        <span class="c1"># self.prepare_state(qlist, 0, l)</span>

        <span class="c1"># 矩阵酉化</span>
        <span class="c1"># matrix = self.unitary(self.norm_F, math.pi/8)</span>
        <span class="c1"># print(&#39;酉化后的矩阵：&#39;)</span>
        <span class="c1"># print(matrix)</span>

        <span class="c1"># 矩阵分解</span>
        <span class="c1"># self.matrix_decompose(qlist, 0, matrix)</span>

        <span class="c1"># 相位估计线路</span>
        <span class="c1"># self.phase_estimation(qlist, 1, self.M)</span>

        <span class="c1"># 受控旋转</span>
        <span class="c1"># self.control_rotate(qlist, self.number, self.M)</span>

        <span class="c1"># hhl线路</span>
        <span class="c1"># self.hhl_circuit(qlist, 0, self.M)</span>

        <span class="c1"># # 带输入的 HHL求解线路</span>
        <span class="c1"># self.solve_hhl_cir(qlist, 0, self.M, self.input_y)</span>

        <span class="c1"># 处理结果</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;结果：&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">qlist</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">init_machine</span> <span class="o">=</span> <span class="n">InitQMachine</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
    <span class="n">qlist</span> <span class="o">=</span> <span class="n">init_machine</span><span class="o">.</span><span class="n">m_qlist</span>
    <span class="n">hhl</span> <span class="o">=</span> <span class="n">HHL</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">hhl</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">qlist</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># 数据的准备</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;./data3.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">data_list</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
                <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="c1"># 数据的整理</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">min_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># hhl = HHL(x, y)</span>
    <span class="c1"># hhl.run()</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>经过以上五步即可实现HHL求解线性方程得到输出的量子态 <span class="math notranslate nohighlight">\(|b, \vec\alpha\rangle\)</span> ，通过将量子态送入到分类线路即可进行分类。下面分析分类的过程。</p>
</div>
<div class="section" id="id4">
<h3>3.3分类<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>以上是训练的去得到量子态 <span class="math notranslate nohighlight">\(|b, \vec\alpha\rangle\)</span> 的过程，接下来是分类，整个分类的线路图如下所示：</p>
<img alt="../_images/分类线路.png" class="align-center" src="../_images/分类线路.png" />
<p>** 第一步、构造training data oracle **</p>
<p>对于一个给定的新数据 <span class="math notranslate nohighlight">\(|\vec x\rangle\)</span> 进行分类，通过构造一个training data oracle实现下面的计算</p>
<div class="math notranslate nohighlight">
\[|\tilde u\rangle = \frac{1}{\sqrt N_\tilde u}(b|0\rangle|0\rangle + \sum\limits_{k=1}^M\alpha_k|\vec x_k||k\rangle|\vec x_k\rangle)\]</div>
<p>其中 <span class="math notranslate nohighlight">\(N_\tilde u=b^2+\sum\limits_{k=1}^M\alpha_k^2|\vec x_k|^2\)</span> 。系数为 <span class="math notranslate nohighlight">\(\{b,\alpha_1|\vec {x_1}|,\alpha_2|\vec {x_2}|,...,\alpha_M|\vec {x_M}|\}\)</span></p>
<p>另外，构造如下态：</p>
<div class="math notranslate nohighlight">
\[|\tilde x\rangle = \frac{1}{\sqrt N_\tilde x}(|0\rangle|0\rangle + \sum\limits_{k=1}^M|\vec x||k\rangle|\vec x\rangle)\]</div>
<p>其中 <span class="math notranslate nohighlight">\(N_\tilde x=M|\vec x|^2+1\)</span> 。系数为 <span class="math notranslate nohighlight">\(\{1,|\vec {x_1}|,|\vec {x_2}|,...,|\vec {x_M}|\}\)</span> ，其中 <span class="math notranslate nohighlight">\(\vec {x_i} = \vec x\)</span></p>
<p>此处的量子线路构建如下图所示</p>
<img alt="../_images/training_data_oracle.png" class="align-center" src="../_images/training_data_oracle.png" />
<p>对输入的系数和向量进行振幅编码</p>
<p>代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 振幅编码</span>
<span class="k">def</span> <span class="nf">prepare_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="c1"># 准备RY旋转角度矩阵</span>
    <span class="n">theata_list</span> <span class="o">=</span> <span class="n">encode_matrix</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="c1"># 构建线路</span>
    <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="n">control_position</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">theatas</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">theata_list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">theata</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">theatas</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">RY</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="o">+</span><span class="n">i</span><span class="p">],</span> <span class="n">theata</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gate</span> <span class="o">=</span> <span class="n">RY</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span> <span class="n">theata</span><span class="p">)</span>
                <span class="c1"># 对当前的索引进行编码</span>
                <span class="n">temp_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="c1"># 插入索引</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">temp_cir</span><span class="p">)</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">gate</span><span class="o">.</span><span class="n">control</span><span class="p">(</span><span class="n">control_position</span><span class="p">))</span>
                <span class="c1"># 还原</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">temp_cir</span><span class="p">)</span>
        <span class="n">control_position</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="o">+</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># print(&#39;draw_input_circuit:&#39;)</span>
    <span class="c1"># pq.draw_qprog(cir)</span>

    <span class="k">return</span> <span class="n">cir</span>
</pre></div>
</div>
<p>编码后，通过如下线路实现 <span class="math notranslate nohighlight">\(|\psi\rangle\)</span></p>
<img alt="../_images/psi.png" class="align-center" src="../_images/psi.png" />
<div class="math notranslate nohighlight">
\[|\psi\rangle=\frac{1}{\sqrt2}(|0\rangle|\tilde u\rangle+|1\rangle|\tilde x\rangle) 。\]</div>
<p>代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 构建线路实现  ψ = 1/sqrt(2)(|0&gt;|u&gt; + |1&gt;|x&gt;)</span>
<span class="k">def</span> <span class="nf">construct_state_psi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">u_coefficient</span><span class="p">,</span> <span class="n">u_vector</span><span class="p">,</span> <span class="n">x_coefficient</span><span class="p">,</span> <span class="n">x_vector</span><span class="p">,</span> <span class="n">oracle_qubits</span><span class="p">):</span>

    <span class="c1"># u线路</span>
    <span class="n">u_cir_position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">u_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_data_oracle</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">u_cir_position</span><span class="p">,</span> <span class="n">u_coefficient</span><span class="p">,</span> <span class="n">u_vector</span><span class="p">)</span>
    <span class="c1"># x线路</span>
    <span class="n">x_cir_position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">oracle_qubits</span>
    <span class="n">x_cir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_data_oracle</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">x_cir_position</span><span class="p">,</span> <span class="n">x_coefficient</span><span class="p">,</span> <span class="n">x_vector</span><span class="p">)</span>
    <span class="c1"># 受控CNOT门</span>
    <span class="n">cir_copy</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">oracle_qubits</span><span class="p">):</span>
        <span class="n">cir_copy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">CNOT</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">u_cir_position</span><span class="o">+</span><span class="n">i</span><span class="p">],</span> <span class="n">qlist</span><span class="p">[</span><span class="n">x_cir_position</span><span class="o">+</span><span class="n">i</span><span class="p">]))</span>
    <span class="c1"># 插入受控 CNOT门</span>

    <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="c1"># 在辅助比特上插入H门,X门</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="p">]))</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="p">]))</span>
    <span class="c1"># 插入u线路</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">u_cir</span><span class="p">)</span>
    <span class="c1"># 插入受控CNOT门</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cir_copy</span><span class="o">.</span><span class="n">control</span><span class="p">([</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="p">]]))</span>
    <span class="c1"># 控制下路x门还原</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="p">]))</span>
    <span class="c1"># 插入x线路</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x_cir</span><span class="p">)</span>

    <span class="c1"># print(&#39;Psi线路:&#39;)</span>
    <span class="c1"># pq.draw_qprog(cir)</span>

    <span class="k">return</span> <span class="n">cir</span>
</pre></div>
</div>
<p>通过如下线路构建 <span class="math notranslate nohighlight">\(|\phi\rangle=\frac{1}{\sqrt2}(|0\rangle-|1\rangle)\)</span> 。</p>
<img alt="../_images/phi.png" class="align-center" src="../_images/phi.png" />
<p>代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 构建线路实现  φ = 1/sqrt(2)(|0&gt; - |1&gt;)</span>
<span class="k">def</span> <span class="nf">construct_state_phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
    <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="p">]))</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="p">]))</span>

    <span class="c1"># print(&#39;Phi线路:&#39;)</span>
    <span class="c1"># pq.draw_qprog(cir)</span>

    <span class="k">return</span> <span class="n">cir</span>
</pre></div>
</div>
<p>** 第二步、swap test实现 **</p>
<p>目标概率 <span class="math notranslate nohighlight">\(P=|\langle\psi|\phi\rangle|^2=\frac{1}{2}(1-\langle\tilde u|\tilde x\rangle)\)</span> 。</p>
<p>通过测量辅助比特0的概率 <span class="math notranslate nohighlight">\(P(|0\rangle)=\frac{1}{2}+\frac{1}{2}|\langle \psi | \phi\rangle|^{2}\)</span> 进行计算得到目标概率P</p>
<p>线路与内积计算线路相同，只是根据线路的数量不同进行一个扩展，代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 通过测量辅助比特0态的概率去反推|&lt;ψ|φ&gt;|^2的概率,即 P(|0&gt;) = 1/2 + 1/2(|&lt;ψ|φ&gt;|^2)</span>
<span class="k">def</span> <span class="nf">swap_test_p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">swap_qubits</span><span class="p">):</span>
    <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="p">]))</span>
    <span class="n">phi_position</span> <span class="o">=</span> <span class="n">position</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">psi_position</span> <span class="o">=</span> <span class="n">phi_position</span><span class="o">+</span><span class="mi">1</span>
    <span class="c1"># 交换线路</span>
    <span class="n">swap_cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">swap_qubits</span><span class="p">):</span>
        <span class="n">swap_cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">SWAP</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">phi_position</span><span class="p">],</span> <span class="n">qlist</span><span class="p">[</span><span class="n">psi_position</span><span class="o">+</span><span class="n">i</span><span class="p">]))</span>
    <span class="c1"># 交换线路受控于辅助比特</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">swap_cir</span><span class="o">.</span><span class="n">control</span><span class="p">([</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="p">]]))</span>
    <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">position</span><span class="p">]))</span>

    <span class="c1"># print(&#39;SWAP-TEST线路:&#39;)</span>
    <span class="c1"># pq.draw_qprog(cir)</span>

    <span class="k">return</span> <span class="n">cir</span>
</pre></div>
</div>
<p>** 第三部、分类 **</p>
<p>通过比较P与0.5的大小来划分输入数据的类别，小于0.5属于-1类，大于0.5属于+1类。</p>
</div>
<div class="section" id="id5">
<h3>4.总结<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>以上是QSVM的所有过程。</p>
<p>通过HHL求解出线性方程的系数，然后将系数带入分类线路进行分类。经过以上过程即可实现一个简单的二分类任务。</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="chapter1.html" class="btn btn-neutral" title="QARM说明文档" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, bylz

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>